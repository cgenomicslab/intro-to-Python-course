# Λίστα με ασκήσεις

## Σημειώσεις για όλες τις ασκήσεις
* **ΑΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```a = input("...")``` (και γενικότερα μην το κάνετε ποτέ αυτό..)
* Όταν η εκφώνηση λέει ότι πρέπει να φτιάξετε συνάρτηση.. πρέπει να φτιάξετε συνάρτηση!
* Αν η εκφώνηση λέει ότι η συνάρτηση πρέπει να επιστρέφει κάτι.. τότε μέσα στη συνάρτησή σας πρέπει κάπου να κάνετε ```return```.
* **AΠΑΓΟΡΕΥΕΤΑΙ** να κάνετε: ```return True```  ή ```return False```  (αν το χρησιμοποιείσετε χάνετε τη μισή άσκηση)


Για παράδειγμα, έστω ότι η άσκηση λέει: 

Φτιάξτε μία συνάρτηση σε python η οποία θα παίρνει σαν όρισμα έναν αριθμό. Η συνάρτηση θα πρέπει να επιστρέφει:
* ```True``` αν ο αριθμός είναι μονός
* ```False``` αν ο αριθμός είναι ζυγός (άρτιος).

Τι να **ΜΗΝ** κάνετε:
```python
def f(n):
    if n%2 == 1:
        return True
    else:
        return False

```

Τι να κάνετε:
```python
def f(n):
    return n%2 == 1
```

* **ΑΠΑΓΟΡΕΥΕΤΑΙ** Να χρησιμοποιήσετε τα εξής ονόματα μεταβλητών: `str`, `id`, `int`, `list`, `tuple`, `dict`. Αυτά είναι ονόματα συναρτήσεων της python. Η python σας αφήνει να τα χρησιμοποιήσετε με το "κόστος" ότι χάνεται η αρχική τους χρήση. π.χ:

```python
print (str(55))

str = 'Mitsos'
print (str(55))
```  

### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 ορίσματα τα οποία θα είναι αριθμοί (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει τον μέσο όρο των δύο αριθμών. Για παράδειγμα θα πρέπει:

```python
print (f(3,5)) # Τυπώνει 4
```

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 ορίσματα, έστω Α και Β. Και τα 2 θα είναι tuples με 2 αριθμούς το κάθε ένα (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει ένα tuple το οποίο θα περιέχει τις συντεταγμένες του μέσου της ευθύγραμμου τμήματος που ορίζεται από τα σημεία Α και Β στον δι-διάστατο χώρο. Για παράδειγμα θα πρέπει:

```python
A = (3,8)
B = (2,5)

print (f(A, B)) # Τυπώνει: (2.5, 6.5)
``` 

**ΠΡΟΣΟΧΗ! Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 1**

Δίνεται ότι αν x<sub>1</sub>, y<sub>1</sub> είναι οι συντεραγμένες του σημείου Α και x<sub>2</sub>, y<sub>2</sub> είναι οι συντεταγμένες του σημείου Β τότε οι συντενταγμένες του μέσου του ευθύγραμου τμήματος ΑΒ είναι (x<sub>1</sub>+x<sub>2</sub>)/2, (y<sub>1</sub>+y<sub>2</sub>)/2 .

### Άσκηση 3
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 ορίσματα, έστω Α και Β. Και τα 2 θα είναι tuples με 2 αριθμούς το κάθε ένα (δεν χρειάζεται να το ελέγξετε αυτό). Έστω ότι οι 2 παράμετροι ορίζουν τα αντίστοιχα 2 σημεία Α,Β στον 2-διάστατο χώρο. 
* Αν τα 2 σημεία Α,Β ταυτίζονται στον 2-διάστατο χώρο, τότε η συνάρτηση θα πρέπει να επιστρέφει το string "δεν υπάρχει ευθεία"
* Αν τα Α και Β ανήκουν σε μία ευθεία παράλληλη στον άξονα Y, τότε η συνάρτηση θα πρέπει να επιστρέφει το string "κάθετη". 
* Διαφορετικά θα πρέπει να επιστρέφει τον συντελεστή διεύθυνσης της ευθείας που ορίζεται από τα Α και Β. Ο [συντελεστής διεύθυνσης](https://en.wikipedia.org/wiki/Slope) μίας ευθείας που περνάει από τo σημεία Α με συντεταγμένες: x<sub>1</sub>, y<sub>1</sub>  και από το σημείο Β με συντεταγμένες x<sub>2</sub>, y<sub>2</sub> είναι: λ=(y<sub>2</sub>-y<sub>1</sub>)/(x<sub>2</sub>-x<sub>1</sub>). Για παράδειγμα θα πρέπει:

```python
A = (3,7)
B = (2,5)
print (f(A,B)) # Τυπώνει: 2.0 , (Δηλαδή: (5-7)/(2-3))

Α = (3,7)
Β = (3,10)
print (f(A,B)) # Τυπώνει "κάθετη"

A=(3,7)
B=(3,7)
print (f(A, B)) # Τυπώνει "δεν υπάρχει ευθεία"
```

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 2 ορίσματα, έστω Α και Β. Και τα 2 θα είναι tuples με 2 αριθμούς το κάθε ένα (δεν χρειάζεται να το ελέγξετε αυτό). Έστω ότι οι 2 παράμετροι ορίζουν τα αντίστοιχα 2 σημεία Α,Β στον 2-διάστατο χώρο. 
* Αν τα 2 σημεία Α,Β ταυτίζονται στον 2-διάστατο χώρο, τότε η συνάρτηση θα πρέπει να επιστρέφει το string "δεν υπάρχει ευθεία"
* Αν τα Α και Β ανήκουν σε μία ευθεία παράλληλη στον άξονα Χ, τότε η συνάρτηση θα πρέπει να επιστρέφει το string "οριζόντια". 
* Διαφορετικά θα πρέπει να επιστρέφει τον συντελεστή διεύθυνσης της ευθείας που είναι κάθετη στην ευθεία που ορίζεται από τα Α και Β.

Δίνεται ότι αν ο συντελεστής διεύθυνσης μίας ευθεία που δεν είναι παράλληλη στον άξονα Χ είναι λ, τότε ο συντελεστής διεύθυνσης της κάθετής της είναι: λ<sup>'</sup> = -1/λ

Για παράδειγμα θα πρέπει:
```python
A = (3,7)
B = (2,5)
print (f(A,B)) # Τυπώνει: -0.5 , (Δηλαδή: -1/((5-7)/(2-3))  )

Α = (3,7)
Β = (0,7)
print (f(A,B)) # Τυπώνει "οριζόντια"

A=(3,7)
B=(3,7)
print (f(A, B)) # Τυπώνει "δεν υπάρχει ευθεία"

```

**Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση της άσκησης 3**

### Άσκηση 5
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 ορίσματα: το c, το r, το a και το b. Το c θα είναι ένα tuple το οποία θα περιέχει 2 αριθμούς και τα r,a,b θα είναι αριθμοί (δεν χρειάζεται να τα ελέγξετε αυτά). Ας υποθέσουμε ότι το c αντιπροσωπεύει το κέντρο ενός κύκλου στον 2-διάστατο χώρο, ότι r είναι η ακτίνα του και ότι υπάρχει η ευθεία ε η οποία ορίζεται από την εξίσωση: y=aχ+b. 
* Αν το κέντρο του κύκλου c ΔΕΝ ανήκει στην ευθεία ε τότε η συνάρτηση πρέπει να επιστρέφει το string "το κέντρο δεν ανήκει στην ευθεία"
* Διαφορετικά θα πρέπει να επιστρέφει 2 tuples, το κάθε ένα με 2 αριθμούς. Τα 2 tuples θα πρέπει να περιέχουν τις συντεταγμένες των 2 σημείων όπου η ευθεία ε τέμνει τον κύκλο. 

Για παράδειγμα:
```python
c = (0, 0)
r = 1
a = 1
b = 0

point_1, point_2 = f(c, r, a, b) 
print (point_1) # Τυπώνει (-0.7071067811865476, -0.7071067811865476)
print (point_2) # Τυπώνει (0.7071067811865476, 0.7071067811865476)


c = (0, 1)
r = 1
a = 1
b = 0

print (f(c, r, a, b)) # Τυπώνει: "το κέντρο δεν ανήκει στην ευθεία"

```

Βοήθεια:

1. Έστω K,L οι συντεταγμένες του κέντρου. Αν η ευθεία y=aχ+b περνάει από το κέντρο θα πρέπει να ισχύει: L = a * K + b   
2. Έστω ότι ένα σημείο που ανήκει στην ευθεία ε και ανήκει στον κύκλο έχει συντεταγμένες: x,y. Θα πρέπει να ισχύει:
   1. y=a * x + b  (αφού ανήκει στην ευθεία)
   2. (x-K)^2 + (y-L)^2 = r^2  (αφού ανήκει στον κύκλο)
   3. Αν αντικαταστήσουμε στην εξίσωση (ii) το y από την εξίσωση (i), θα έχουμε: (x-K)<sup>2</sup> + ((a * x + b)-L)<sup>2</sup> = r^2
   4. Αν λύσουμε αυτή την εξίσωση τότε θα δούμε ότι [έχει δύο λύσεις](https://i.imgur.com/rnuKi3W.png). Για κάθε ένα από αυτά τα "χ" μπορούμε να υπολογίσουμε το αντίστοιχο y από την εξίσωση της ευθείας (y = a * x + b)
3. Για τη τετραγωνική ρίζα μπορείτε να χρησιμοποιήσετε έναν από τους παρακάτω τρόπους:

```python
from math import sqrt

print (sqrt(16))
print (16**0.5)
```

### Άσκηση 6 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 4 ορίσματα: a,b,P,d. Τα a,b,d θα είναι αριθμοί και το P θα είναι ένα tuple το οποίο θα αποτελείται από 2 αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). 
* Αν το σημείo P που ορίζεται από τις συντεταγμένες που υπάρχουν στο tuple P **ΔΕΝ** ανήκει στην ευθεία ε που ορίζεται από την εξίσωση: y=ax+b. Τότε επιστρέφει το string "λάθος"
* Διαφορετικά θα πρέπει να επιστρέφει 2 tuples, το κάθε ένα με 2 αριθμούς. Τα 2 tuples θα πρέπει να περιέχουν τις συντεταγμένες των 2 σημείων πάνω στην ευθεία ε που απέχουν από το σημείο P απόσταση d.

Δηλαδή θα πρέπει:
```python
a=1
b=0
P=(0,0)
d=1

point_1, point_2 = f(a,b,P,d)
print (point_1) # Τυπώνει (-0.7071067811865476, -0.7071067811865476)
print (point_2) # Τυπώνει (0.7071067811865476, 0.7071067811865476)

a=1
b=0
P=(0,1)
d=1
print (f(a,b,P,d)) # Τυπώνει "λάθος"
```

**Είναι υποχρεωτικό να χρησιμοποιήσετε την συνάρτηση της άσκησης 5**

### Άσκηση 7
Φτιάξτε μία συνάρτηση η οποία θα παίρει 2 ορίσματα Α,Β. Τα Α και Β θα είναι tuples με 2 αριθμούς το κάθε ένα (δεν χρειάζεται να το ελέγξετε αυτό).
* Αν τα Α και Β ταυτίζονται θα πρέπει να επιστρέφει τo string "λάθος"
* Διαφορετικά θα επιστρέφει ένα tuple με δύο αριθμούς. Το tuple αυτό θα είναι οι συντεταγμένες του μοναδικού σημείου P το οποίο έχει τις εξής ιδιότητες:
   * Ανήκει στην ευθεία που ορίζεται από τα 2 σημεία Α και Β
   * Απέχει από το Α τόσο όσο η απόσταση μεταξύ των Α και Β
   * Δεν είναι το Β

Για παράδειγμα θα πρέπει:
```python
A = (0,0)
B = (1,0)

print (f(A,B)) # Επιστρέφει: (-1, 0)
```

**Είναι υποχρεωτικό να χρησημποιήσετε τη συνάρτηση της άσκησης 5**



### Άσκηση 8
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 ορίσματα Α,Β,d. Τα Α και Β θα είναι tuples με 2 αριθμούς το κάθε ένα και το d θα είναι ένας αριθμός (δεν χρειάζεται να το ελέγξετε αυτό). 
* Αν τα 2 σημεία στον 2-διάστατο χώρο που ορίζονται από τις συντεταγμένες που υπάρχουν στα tuples Α και Β ταυτίζονται, τότε θα πρέπει να επιστρέφει τo string "λάθος".
* Διαφορετικά επιστρέφει 2 tuples, το κάθε ένα με 2 αριθμούς. Το κάθε tuple εκπροσωπεί τα 2 σημεία Κ,Λ τα οποία ανήκουν στη μεσοκάθετο της Α,Β και απέχουν από το μέσο της Α,Β απόσταση d.

Βοήθεια:
1. Υπολογίστε το μέσο της Α,Β (συνάρτηση άσκησης 2), έστω Γ.
2. Υπολογίστε το slope της κάθετης στην Α,Β, (συνάρτηση άσκησης 4) , έστω λ<sup>'</sup>
3. Αν η εξίσωση της μεσοκαθέτου είναι  y = ax + b. Τότε: a = λ<sup>'</sup>. Γνωρίζουμε ένα σημείο πάνω στην μεσοκάθετο, (το Γ) οπότε μπορούμε να υπολογίσουμε το b.
4. Αφού ξέρουμε τα a,b της ευθείας της μεσοκαθέτου, ένα σημείο πάνω στη μεσοκάθετο (το Γ) και την απόσταση d, μπορούμε να χρησιμοποιήσουμε τη συνάρτηση της άσκησης 5 για να υπολογίσουμε τα Κ,Λ

**Είναι υποχρεωτικό να χρησιμοποιήσετε της συναρτήσεις των ασκήσεων 2,4 και 5**

Για παράδειγμα θα πρέπει:

```python
Α = (-0.7071067811865476, +0.7071067811865476)
Β = (0.7071067811865476, -0.7071067811865476)
d = 1

point_1, point_2 = f(A, B, d)
print (point_1) # Τυπώνει: (-0.7071067811865476, -0.7071067811865476)
print (point_2) # Τυπώνει: (+0.7071067811865476, +0.7071067811865476)
```

### Άσκηση 9
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 αριθμούς: a,b,tolerance. Η παράμετρος tolerance θα έχει τη default τιμή: 0.00001 . 
* Αν η απόλυτη διαφορά των a και b είναι μικρότερη από το tolerance τότε επιστρέφει `True`
* Διαφορετικά επιστρέφει `False`

**Προσοχή! H συνάρτηση ΔΕΝ επιστρέφει κάποιο string!**

Για παράδειγμα θα πρέπει:
```python
print (f( 1.2345678,  1.234587)) # Επιστρέφει False
print (f( 1.2345678,  1.234587, tolerance = 0.0001)) # Επιστρέφει True
```

### Άσκηση 10
Φτιάξτε μία συνάρτηση η οπoία θα παίρνει σαν παράμετρο ένα string το οποίο αναπαριστάει μία ημερομηνία με το εξής φορμάτ: MM/DD/YYYY (αμερικάνικο). Για παράδειγμα η ημερομηνια 1 Δεκεμβρίου 2022 αναπαριστάται ως: 12/01/2022. Η συνάρτηση θα πρέπει να επιστρέφει ένα string με την ίδια ημερομηνία αλλά με το φορμάτ DD/MM/YYYY (Ευρωπαϊκό). Για παράδειγμα θα πρέπει:

```python
print (f('12/01/2022')) # Επιστρέφει '01/12/2022'
```
**Απαγορεύεται να χρησιμοποιήσετε regular expressions!**

### Άσκηση 11 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το άθροισμα του διπλάσιου των αριθμών της λίστας που ανήκουν στο κλειστό διάστημα [10, 20]. Για παράδειγμα θα πρέπει:

```python
l = [3,15,7,8,12,20,3]
print (f(l)) # επιστρέφει 94 (15*2 + 12*2 + 20*2)
``` 

* Είναι υποχρεωτικό να χρησιμοποιήσετε `map`, `filter`.
* Μη χρησιμοποιήσετε list comprehension
* Μη χρησιμοποιήσετε `for`, `while`

### Άσκηση 12 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το άθροισμα του διπλάσιου των αριθμών της λίστας που ανήκουν στο κλειστό διάστημα [10, 20]. Για παράδειγμα θα πρέπει:

```python
l = [3,15,7,8,12,20,3]
print (f(l)) # επιστρέφει 94 (15*2 + 12*2 + 20*2)
``` 

* Είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension 
* Μη χρησιμοποιήσετε `map`, `filter`
* Μη χρησιμοποιήσετε `for`, `while` (εκτός από το `for` του list comprehensio)


### Άσκηση 13 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 λίστες a,b. Η κάθε λίστα θα περιέχει tuples με 2 αριθμούς το κάθε ένα (δεν χρειάζεται να το ελέγξετε αυτό). H συνάρτηση θα πρέπει να επιστρέφει την μεγαλύτερη απόσταση μεταξύ όλων των σημείων του a και όλων των σημείων του b.

Για παράδειγμα:
```python
a = [(9.68, 9.55), (4.99, 8.97), (8.67, 6.28), (5.98, 8.99), (7.54, 0.94), (0.04, 7.76), (5.47, 7.83), (8.78, 0.17), (1.4, 4.45), (6.74, 2.76)]
b = [(8.02, 6.82), (2.08, 4.8), (1.85, 5.42), (9.92, 8.86), (0.84, 7.62)]

print (f(a,b)) # Τυπώνει: 10.887887765769815 
```
* Είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension 
* Ως απόσταση εννοείται η ευκλείδεια απόσταση

### Άσκηση 14
Φτιάξτε μία συνάρτηση, έστω `f1` η οποία θα παίρνει 3 παραμέτρους. O πρώτος (έστω K) θα είναι ένα tuple με 2 αριθμούς, ο δεύτερος και ο τρίτος (έστω r και phi) θα είναι αριθμοί (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα επιστρέφει ένα tuple το οποίο περιέχει 2 αριθμούς. Οι αριθμοί αυτοί θα είναι οι συντεταγμένες του σημείου P το οποίο έχει τις εξής ιδιότητες:
* Το P ανήκει πάνω στον κύκλο με κέντρο το K και ακτίνα r 
* H ευθεία που ορίζεται από το ευθύγραμμο τμήμα ΡΟ σχηματίζει γωνία phi μοίρες με τον άξονα X'X. 

Για παράδειγμα θα πρέπει:

```python
K = (0,0)
r = 1
phi = 45

print (f(K,r,phi)) # Τυπώνεθ: (0.7071067811865476, 0.7071067811865476)


K = (0,0)
r = 1
phi = 90

f(K,r,phi) # Τυπώνει: (0.0, 1.0)
```


Δίνεται πως μπορείτε να υπολογίσετε το ημίτονο και συνημίτονο των phi μοιρών (αν το χρειαστείτε!):
```python
from math import sin, cos, pi

phi = 45
# Ημίτονο:
sin(phi/360 * 2*pi) # 0.7071067811865475 

# Συνημίτονο:
cos(phi/360 * 2*pi) # 0.7071067811865475 
```

Φτιάξτε μία συνάρτηση με το όνομα ```f2``` η οποία θα παίρνει σαν παράμετρο 3 αριθμούς: O πρώτος (έστω K) θα είναι ένα tuple με 2 αριθμούς, ο δεύτερος (έστω r) θα είναι ένας αριθμός και ο τρίτος (έστω n) θα είναι ένας ακέραιος αριθμός (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτηση θα επιστρέφει μία λίστα με tuples. Κάθε tuple θα έχει δύο αριθμούς. Η λίστα θα περιέχει όλα τα σημεία τα οποία έχουν τις εξής ιδιότητες:
* Όλα τα σημεία ανήκουν στον κύκλο που έχει κέντρο Κ και ακρίνα r
* Τα σημεία σχηματίζουν ένα [κανονικό πολύγωνο τάξης n](https://el.wikipedia.org/wiki/%CE%9A%CE%B1%CE%BD%CE%BF%CE%BD%CE%B9%CE%BA%CF%8C_%CF%80%CE%BF%CE%BB%CF%8D%CE%B3%CF%89%CE%BD%CE%BF).
* Το σημείο (K[0]+r, K[1]) είναι υποχρεωτικό να υπάρχει στη λίστα που επιστρέφετε. 

Σημείωσεις:
* Είναι υποχρεωτικό να χρησιμοποιήσετε τη συνάρτηση `f1`.
* Είναι υποχρεωτικό να χρησιμοποιήσετε list comprehension 
* Απαγορεύεται να χρησιμοποιήσετε numpy (και.. συναφείς βιβλιοθήκες)

Για παράδειγμα θα πρέπει:
```python
K = (0,0)
r = 1

print (f(K, r, n=3)) # Τυπώνει:  [(1.0, 0.0), (-0.4999999999999998, 0.8660254037844388), (-0.5000000000000004, -0.8660254037844384)]

print (f(K, r, n=4)) # Τυπώνει:  [(1.0, 0.0), (6.123233995736766e-17, 1.0), (-1.0, 1.2246467991473532e-16), (-1.8369701987210297e-16, -1.0)]

print (f(K, r, n=5)) # Τυπώνει: [(1.0, 0.0), (0.30901699437494745, 0.9510565162951535), (-0.8090169943749473, 0.5877852522924732), (-0.8090169943749475, -0.587785252292473), (0.30901699437494723, -0.9510565162951536)] 
```

### Άσκηση 15 
Δίνεται ο παρακάτω κώδικας ο οποίος φτιάχνει μία λίστα με όλα τα φύλλα της τράπουλας.

```python
suits = list('♠♥♦♣')
symbols = list('23456789JQKA') + ['10']

l = [x+y for x in suits for y in symbols]
print (l)
```

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει μία λίστα με όλα τα φύλλα του παιχνιδιού [UNO](https://en.wikipedia.org/wiki/Uno_%28card_game%29). Όλα τα φύλλα (108) βρίσκονται σε αυτή την εικόνα:

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/UNO_cards_deck.svg/1920px-UNO_cards_deck.svg.png)

Σύμφωνα με τη wikipedia:
> The deck consists of 108 cards: four each of "Wild" and "Wild Draw Four", and 25 each of four colors (red, yellow, green, blue). Each color consists of one zero, two each of 1 through 9, and two each of "Skip", "Draw Two", and "Reverse". These last three types are known as "action cards". 

Για να κωδικοποήσετε τα φύλλα σας χρησιμοποιήστε τους εξής χαρακτήρες:
* Τους χαρακτήρες: `0`,`1`,`2`,`3`,`4`,`5`,`6`,`7`,`8`,`9` για τους αριθμούς
* Τους χαρακτήρες: `R`, `Y`, `G`, `B` για τα χρώματα.
* Τον χαρακτήρα: `Ø` για το `Skip`.
* Τον χαρακτήρα: `⇋` για το `Reverse`.
* Τον χαρακτήρα: `☍` για το `Draw Two (+2)`.
* Τον χαρακτήρα: `⎈` για το `Wild`.
* Τον χαρακτήρα: `⚃` για το `Wild Draw Four`.

Τα φύλλα που έχουν χρώμα αποτελούνται από 2 χαρακτήρες: πρώτα πάει το χρώμα και μετά το είδος (για παράδειγμα: `G9`, `BØ`). 
Θα πρέπει δηλαδή:
```python
print (f()) # Τυπώνει: ['R0', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8', 'R9', 'RØ', 'R⇋', 'R☍', 'Y0', 'Y1', 'Y2', 'Y3', 'Y4', 'Y5', 'Y6', 'Y7', 'Y8', 'Y9', 'YØ', 'Y⇋', 'Y☍', 'G0', 'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'GØ', 'G⇋', 'G☍', 'B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'BØ', 'B⇋', 'B☍', '⎈', '⚃', '⎈', '⚃', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8', 'R9', 'RØ', 'R⇋', 'R☍', 'Y1', 'Y2', 'Y3', 'Y4', 'Y5', 'Y6', 'Y7', 'Y8', 'Y9', 'YØ', 'Y⇋', 'Y☍', 'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9', 'GØ', 'G⇋', 'G☍', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'BØ', 'B⇋', 'B☍', '⎈', '⚃', '⎈', '⚃']
```

Σημειώσεις: 
* Η σειρά που τα τυπώνει δεν έχει σημασία. Εσείς μπορείτε να φτιάξετε μία λίστα με διαφορετική σειρά
* Θα πρέπει να τη λύσετε με list comprehension(s) τα οποία θα παράγουν τη ζητούμενη λίστα. 
* Bonus: Αν τη λύσετε με *ένα* list comprehension θα πάρετε bonus: 12/10. 

### Άσκηση 16 
Ένα μενού εστιατορίου αποτελείται από 3 ορεκτικά:
```python
orektika = ['ντολμαδάκια', 'φάβα', 'μελιτζανοσαλάτα']
```
Επίσης αποτελείται από 2 σαλάτες:
```python
salates = ['χωριάτικη', 'μαρούλι']
```
Και τρία κύρια πιάτα:
```python
kyria = ['σπλινάντερο', 'γαρδούμπες', 'μοσχαροκεφαλή']
```
Ο σεφ του εστιατορίου λέει ότι ένας πελάτης μπορεί να πάρει οποιαδήποτα συνδοιασμό θέλει (ένα ορκετικό, μία σαλάτα και ένα κυρίος πιάτο), αλλά υπάρχουν οι παρακάτω περιορισμοί:
* Αν ο πελάτης πάρει `'ντολμαδάκια'` για ορεκτικό τότε δεν μπορεί να πάρει `'μοσχαροκεφαλή'` για κύριο πιάτο
* Αν ο πελάτης πάρει `'μαρούλι'` για σαλάτα τότε μπορεί να πάρει μόνο `'σπλινάντερο'` για κύριο πιάτο.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 παράμετρους. Και οι τρεις θα είναι λίστες με τις τιμές που υπάρχουν παραπάνω (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με tuples. Κάθε tuple θα έχει και έναν συνδυασμό από ορεκτκό, σαλάτα, κύριο πιάτο. Η λίστα θα περιέχει όλους τους δυνατούς συνδυασμούς που μπορεί να παραγγείλει ένας πελάτης, σεβόμενος τους περιορισμούς του σεφ. 

### Άσκηση 17 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο η οποία θα είναι string (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει ένα string το οποίο θα περιέχει μόνο το πρώτο γράμμα κάθε λέξης του string της παραμέτρου. Για παράδειγμα:

```python
print (f('Πανεπιστήμιο Κρήτης')) # Τυπώνει ΠΚ
print (f('ΕΘΝΙΚΟΣ ΟΡΓΑΝΙΣΜΟΣ ΤΟΥΡΙΣΜΟΥ')) # Τυπώνει ΕΟΤ
``` 

* Θεωρούμε ότι όλες οι λέξεις χωρίζονται με ένα space
* Θα πρέπει να την υλοποιήσετε ή με filter/map ή με list comprehension 
* Δίνεται ότι:
   * Μπορείτε να φτιάξετε μία λίστα με όλα τα γράμματα ενός string:
```python
print (list('hello'))
```
   *  αν θέλετε να ενώσετε όλα τα γράμματα μίας λίστας που αποτελείται από string μπορείτε να χρησιμομποιήσετε τη `''.join`:
```python
a = ['h', 'e', 'l', 'l', 'o']
print (''.join(a))
```

### Άσκηση 18 
Μία παλινδρομική ακολουθία ορίζεται αυτή η οποία μπορεί να διαβαστεί το ίδιο από την αρχή προς το τέλος και από το τέλος προς την αρχή (π.χ: `GCCG`, `GCTCG`)
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμερτο. Η συνάρτηση θα επιστρέφει μία λίστα με όλες οι δυνατές ακολουθίες DNA που αποτελούνται από 5 νουκλεοτίδια και είναι παλινδρομικές. 

Δίνεται ο παρακάτω κώδικας ο οποίος παράγει όλες τις ακολουθίες DNA με μέγεθος 3:
```python
[a+b+c for a in 'ACGT' for b in 'ACGT' for c in 'ACGT']
```

### Άσκηση 19
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν ακέραιο αριθμό n (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα η οποία θα αποτελείται από λίστες. Η πρώτη υπολίστα θα έχει τον αριθμό 1, η δεύτερη θα έχει τους αριθμούς 1,2 η τρίτη τους αριθμούς 1,2,3 κτλ.. η τελευταία θα έχεις τους αριθμούς 1,2,3,...,n. Για παράδειγμα θα πρέπει:

```python
print (f(3)) # Τυπώνει: [[1], [1,2], [1,2,3]]
print (f(4)) # Τυπώνει: [[1], [1,2], [1,2,3], [1,2,3,4]]
```

### Άσκηση 20
Φτιάξτε μία συνάρτηση η οποία θα παιρνει σαν παράμετρο 2 λίστες α,β. Η πρώτη θα είναι μία λίστα με αριθμούς και η δεύτερη θα είναι μία λίστα με tuples όπου κάθε tuple θα αποτελείται από δύο αριθμούς κ,λ τέτοιους ώστε κ>λ (δεν χρειάζεται να τα ελέγξετε όλα αυτά). Η συνάρτηση θα επιστρέφει μία λίστα η οποία θα περιέχει τους αριθμούς της λίστας α οι οποίοι υπάρχουν σε τουλάχιστον ένα από τα κλειστά διαστήματα που ορίζονται από τα tuples της παραμέτρου β. Για παράδειγμα θα πρέπει:

```python
a = [3,10, 17]
b = [(4,7), (0,1), (13,18), (21,25)]

print (f(a,b)) # Τυπώνει: [17] (μόνο το 17 υπάρχει τουλάχιστον σε ένα από τα διαστήματα της b (το [13, 18]))

a = [3,10, 17]
b = [(4,7), (0,1), (13,18), (16,25)]

print (f(a,b)) # Τυπώνει: [17] (μόνο το 17 υπάρχει τουλάχιστον σε ένα από τα διαστήματα της b (τα [13, 18] και [16,25]))

a = [17, 3,10, 17]
b = [(4,7), (0,1), (13,18), (16,25)]

print (f(a,b)) # Τυπώνει: [17, 17] 


```

### Άσκηση 21

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα l. Η λίστα θα περιέχει tuples. Κάθε tuple θα περιέχει 2 strings (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτη θα επιστρέφει True/False ανάλογα με το αν υπάρχει έστω και ένα tuple όπου και τα δύο string να αρχίζουν με φωνήεν. 

Δινεται το παρακάτω string το οποίο περιέχει όλα τα φωνήεν (στα Αγγλικά) για το οποίο πρέπει να ελέγχετε:
```python
vowels = 'AaEeIiOoUu'
```

Για παράδειγμα θα πρέπει:

```python
l  =[('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει False (κανένα ζευγάρι δεν έχει και τα 2 πρώτα γράμματα φωνήεντα )

l  =[('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Eleftheria', 'Arvanitaki'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει True 

```

Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε for / break

### Άσκηση 22
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα l. Η λίστα θα περιέχει tuples. Κάθε tuple θα περιέχει 2 strings (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτη θα επιστρέφει το πλήθος από τα στοιχεία της l στα οποία και τα δύο string αρχίζουμ με φωνήεν. 

Δινεται το string to οποίο περιέχει όλα τα φωνήεν (στα Αγγλικά) για το οποίο πρέπει να ελέγχετε:
```python
vowels = 'AaEeIiOoUu'
```

Για παράδειγμα θα πρέπει:

```python
l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει 0 (κανένα ζευγάρι δεν έχει και τα 2 πρώτα γράμματα φωνήεντα )

l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Eleftheria', 'Arvanitaki'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει 1 

l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Eleftheria', 'Arvanitaki'), ('Maria', 'Aliferh'),  ('Aristotelhs', 'Onassis')]
print (f(l)) # Τυπώνει 2

```

Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε for / continue

### Άσκηση 23
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο δύο λίστες a,b. Η κάθε λίστα θα περιέχει strings και οι δύο λίστες θα έχουν το ίδιο μέγεθος (δεν χρειάζεται να τα ελέγξετε αυτά). Υποθέτουμε ότι η πρώτη λίστα θα περιέχει τα ονόματα και η δεύτερη τα επίθετα από μία ομάδα ανθρώπων. Η συνάρτηση θα πρέπει να επιστρέφει το πλήθος των ατόμων όπου και το όνομα αλλά και το επίθετο αρχίζουν από φωνήεν. 

Δινεται το string οποίο περιέχει όλα τα φωνήεν (στα Αγγλικά) για τα οποία πρέπει να ελέγχετε:
```python
vowels = 'AaEeIiOoUu'
```

Για παράδειγμα θα πρέπει:

```python
a = ['Alexandros', 'Spiros', 'Maria']
b = ['Kanterakis', 'Mpimpilas', 'Aliferh']
print (f(a,b)) # Τυπώνει 0 (κανένα ζευγάρι δεν έχει και τα 2 πρώτα γράμματα φωνήεντα )


a = ['Alexandros', 'Spiros', 'Eleftheria', 'Maria']
b = ['Kanterakis', 'Mpimpilas', 'Arvanitaki', 'Aliferh']
print (f(a,b)) # Τυπώνει 1 

a = ['Alexandros', 'Spiros', 'Eleftheria', 'Maria', 'Aristotelhs']
b = ['Kanterakis', 'Mpimpilas', 'Arvanitaki', 'Aliferh', 'Onassis']
print (f(a,b)) # Τυπώνει 2

```

hint: `zip`

### Άσκηση 24 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα l. Η λίστα θα περιέχει tuples. Κάθε tuple θα περιέχει 2 strings (δεν χρειάζεται να τα ελέγξετε αυτά). Η συνάρτη θα επιστρέφει ένα string. To string αυτό θα είναι το επίθετο του ατόμου του οποίου το επίθετο είναι πρώτο αλφαβητικά από όλα τα άτομα στα οποία και το όνομα αλλά και το επίθετο είναι φωνήεντα. Αν δεν υπάρχει όνομα όπου και το όνομα και το επίθετο είναι φωνήεν, θα επιστρέφει `None`. 

Δινεται string το οποίο περιέχει όλα τα φωνήεν (στα Αγγλικά) για το οποίο πρέπει να ελέγχετε:
```python
vowels = 'AaEeIiOoUu'
```

Για παράδειγμα θα πρέπει:

```python
l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει `None` (κανένα ζευγάρι δεν έχει και τα 2 πρώτα γράμματα φωνήεντα )

l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Aristotelhs', 'Onassis'), ('Maria', 'Aliferh')]
print (f(l)) # Τυπώνει `Onassis`

l = [('Alexandros', 'Kanterakis'), ('Spiros', 'Mpimpilas'), ('Eleftheria', 'Arvanitaki'), ('Maria', 'Aliferh'),  ('Aristotelhs', 'Onassis')]
print (f(l)) # Τυπώνει 'Arvanitaki'

```

Σημείωση: απαγορεύεται να χρησιμοποιήσετε ταξινόμηση (sort, sorted)

### Άσκηση 25
Στις φετινές πανελλήνιες, στα μαθηματικά, "έπεσε" η μελέτη της συνάρτησης f(x)=e<sup>x</sup>-3x. Η αλλιώς:

```python
import math
def f(x):
    return math.exp(x)-3*x

```

Αν τη πλοτάρουμε για Χ από 0 μέχρι 2 θα πάρουμε την εξής γραφική παράσταση:
![img](https://i.imgur.com/dpYfDVN.png)


Όπως παρατηρείτε από τη γραφική παράσταση, η συνάρτηση αυτή τέμνει τον άξονα Χ σε 2 σημεία. Το πρώτο είναι μεταξύ του 0 και το 1 και το δεύτερο μεταξύ του 1 και του 2. Άρα η εξίσωση f(x)=0 έχει 2 λύσεις, μία μέσα σε κάθε ένα από αυτά τα διαστήματα. Η ακριβής λύση αυτης της εξίσωσης είναι πολύ δύσκολο να βρεθεί. Ευτυχώς όμως χρησιμοποιώντας τη python μπορούμε να προσεγγίσουμε αριθμητικά τη λύση με αρκετά μεγάλη ακρίβεια.

Φτιάξτε μία συνάρτηση με το όνομα `sol` η οποία θα παίρνει 3 παραμέτρους. Η πρώτη θα είναι μία συνάρτηση (έστω `f`) η δεύτερη θα είναι ένας αριθμός (έστω `a`) και η τρίτη ένας αριθμός (έστω `b`). Θα υποθέσουμε ότι υπάρχει σίγουρα μία τιμή μεταξύ του a και του b το οποίο μηδενίζει την f. Η συνάρτηση θα υπολογίζει τις τιμές της `f` ξεκινώντας από το `a` και "πηγαίνοντας" προς το `b` με βήμα `0.01`. Δηλαδή στην αρχή θα υπολογίζει το `f(a)` μετά το `f(a+0.01)` μετά το `f(a+0.02)` κτλ. Όταν η τιμή της f αλλάξει πρόσιμο (δηλαδή από θετική γίνει αρνητική ή το αντίθετο) τότε η συνάρτηση πρέπει να σταματάει και να επιστρέφει τη τελευταία τιμή x, για την οποία εκτίμησε το f(x). Δίνονται μερικά παραδείγματα:

```python
print (sol(f,0,1)) # τυπώνει 0.62
print (sol(f,1,2)) # τυπώνει 1.52
```

σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε `while`.

### Άσκηση 26 
Ας υποθέσουμε ότι έχω ένα κεφάλαιο 10.000 ευρώ. Επίσης ας υποθέσουμε ότι:
* Κάθε χρόνο πληρώνω 1000 ευρώ για διάφορα έξοδα
* Σε ότι μένει αφού πληρώσω τα 1000ε, προσθέτω σε αυτό το κεφάλαιο, ένα 15%.

Σε πόσα χρόνια το κεφάλαιο αυτό θα υπερ-διπλασιαστεί (ή αλλιώς θα ξεπεράσει τα 20.000 ευρώ);

Φτοιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα υπολογίζει και θα επιτρέφει την απάντηση στο παραπάνω ερώτημα.

Επεξήγηση:
* Στο τέλος του πρώτου χρόνου θα έχω: 10.000 - 1000 = 9000. 9000 + 15% = 10350 
* Στο τέλος του δεύτερου χρόνου θα έχω: 10.350 - 1000 = 9450. 9350 + 15% = 10752.5
* ...

σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε `while`.

### Άσκηση 27 
Ποιος είναι ο μικρότερος αριθμός n (n ακέραιος, και θετικός) τέτοιος ώστε o 3<sup>n</sup> να περιέχει όλα τα ψηφία από το 0 μέχρι και το 9; Φτιάξτε μία συνάρτηση η οποία να υπολογίζει και να επιστρέφει την απάντηση σε αυτή την ερώτηση. 

σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε `while`.

### Άσκηση 28
Έστω ότι ο 2 είναι ο πρώτος πρώτος αριθμός. Δηλαδή:
* Ο 1ος πρώτος είναι ο 2
* Ο 2ος πρώτος είναι ο 3
* Ο 3ος πρώτος είναι ο 5
* Ο 4ος πρώτος είναι ο 7
* Ο 5ος πρώτος είναι ο 11
* κτλ..

Για κάθε πρώτο αριθμό p μπορούμε να ορίσουμε το κλάσμα n/p όπου n είναι η σειρά του αν ξεκινήσουμε να μετράμε τους πρώτους από τον 2. Για παράδειγμα το κλάσμα n/p για τους παραπάνω πρώτους είναι:

* Για τον 2 είναι 1/2 = 0.5
* Για τον 3 είναι 2/3 = 0.66
* Για τον 5 είναι 3/5 = 0.6
* Για τον 7 είναι 4/7 = .5714285714285714
* Για τον 11 είναι 5/11 = 0.45454545454545453 

Ποιος είναι ο μικρότερος πρώτος αριθμός για τον οποίο το κλάσμα n/p είναι μικρότερο από 0.1; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα η συνάρτηση θα υπολογίζει και θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

### Άσκηση 29 
Δύο πρώτοι αριθμοί λέγονται συνεχόμενοι αν δεν υπάρχει άλλος πρώτος αριθμός μεταξύ τους. Το ίδιο μπορεί να οριστεί για παραπάνω από 2 αριθμούς. Για παράδειγμα οι αριθμοί: 11, 13, 17, 19 είναι όλοι συνεχόμενοι πρώτοι. Ποιος είναι ο μικρότερος πρώτο αριθμός ο οποίος είναι το άθροισμα από 7 συνεχόμενους πρώτους αριθμούς; 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα υπολογίζει και θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

### Άσκηση 30 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν ακέραιο αριθμό n (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα πρέπει να επιστρέφει ένα string το οποίο θα είναι ένα χαριτωμένο αστεράκι σύμφωνα με τα παρακάτω παραδείγματα:


```python
print (f(1))
# Τυπώνει:
*

print (f(2))
# Τυπώνει:
 *
***
 *

print (f(3))
# Τυπώνει:
  *
 ***
*****
 ***
  *

print (f(4))
# Τυπώνει:
   *
  ***
 *****
*******
 *****
  ***
   *

```

### Άσκηση 31
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με strings (δεν χρειάζαται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει ένα σύνολο από τους χαρακτήρες (μικρούς λατινικούς) που δεν υπάρχουν σε κανένα από τα strings της λίστας της παραμέτρου. 
Για παράδειγμα θα πρέπει:

```python
ls = [
        'agapi',
        'olympia',
        'andreas',
        'nikos',
        'elena',
        'aggelos',
        'anna',
        'katerina',
    ]

print (f(ls)) # Τυπώνει: {'b', 'c', 'f', 'h', 'j', 'q', 'u', 'v', 'w', 'x', 'z'}

```

Δίνεται η παρακάτω συνάρτηση η οποία επιστρέφει ένα σύνολο με όλους τους μικρούς λατινικούς χαρακτήρες:

```python
import string

def set_letters():
    return set(string.ascii_lowercase)
```

### Άσκηση 32
Έστω το παρακάτω dictionary:
```python

d = {
 '1': (5, 4),
 '2': (6, 3),
 '3': (2, 9),
 '4': (4, 9),
 '5': (9, 2),
 '6': (10, 10),
 '7': (8, 6),
 '8': (10, 4),
 '9': (4, 3),
 'X': (1, 6),
 }

```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιτρέφει το ίδιο dictionary αλλά τα tuples στα values θα είναι ανεστραμμένα. Για παράδειγμα θα πρέπει:

```python
print (f(d)) # Τυπώνει:  

{'1': (4, 5),
 '2': (3, 6),
 '3': (9, 2),
 '4': (9, 4),
 '5': (2, 9),
 '6': (10, 10),
 '7': (6, 8),
 '8': (4, 10),
 '9': (3, 4),
 'X': (6, 1),
}

```

### Άσκηση 33
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο n, η οποία θα είναι ένας ακέραιος αριθμός (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλοι οι αριθμοί από το 1 μέχρι και το n. Τα values θα είναι το πλήθος των διαιρετών που έχει το αντίστοιχο κλειδί χωρίς το 1 και το n. Για παράδειγμα το 10 έχει 2 διαιρέτες: (το 2 και το 5) και το 24 έχει 6 διαιρέτες (το 2,3,4,6,8,12). Δίνεται ένα παράδειγμα:

```python
print (f(50)) # Τυπώνει:
{1: 0,
 2: 0,
 3: 0,
 4: 1,
 5: 0,
 6: 2,
 7: 0,
 8: 2,
 9: 1,
 10: 2,
 11: 0,
 12: 4,
 13: 0,
 14: 2,
 15: 2,
 16: 3,
 17: 0,
 18: 4,
 19: 0,
 20: 4,
 21: 2,
 22: 2,
 23: 0,
 24: 6,
 25: 1,
 26: 2,
 27: 2,
 28: 4,
 29: 0,
 30: 6,
 31: 0,
 32: 4,
 33: 2,
 34: 2,
 35: 2,
 36: 7,
 37: 0,
 38: 2,
 39: 2,
 40: 6,
 41: 0,
 42: 6,
 43: 0,
 44: 4,
 45: 4,
 46: 2,
 47: 0,
 48: 8,
 49: 1,
 50: 4}

```

### Άσκηση 34 
Η παρακάτω λίστα περιέχει dictionaries. Κάθε dictionary περιέχει τα εξής κλειδιά / τιμές:

* `name`: Περιέχει το όνομα του γονιδίου (τυχαίο)
* `start`: Οι θέσεις που ξεκινάνε κάθε ένα από τα exons του.
* `end`: Οι θέσεις που τερματίζουν κάθε ένα από τα exons του.

```python
genes = [
 {'name': 'VLDZ',
  'start': [1335, 2287, 3395, 4344],
  'end': [1568, 2727, 3976, 4864]
 },
 {'name': 'SUVM',
  'start': [1014, 2064, 3131, 4335],
  'end': [1608, 2670, 3583, 4775]
 },
 {'name': 'AMPM',
  'start': [1386, 2305, 3306, 4010, 5394, 6260],
  'end': [1972, 2786, 3710, 4601, 5871, 6702]
 },
 {'name': 'ZNYP',
  'start': [1025, 2272, 3185, 4225, 5159, 6362],
  'end': [1942, 2679, 3552, 4584, 5961, 6725]
 },
 {'name': 'DVLY',
  'start': [1221, 2330, 3013, 4240, 5386, 6230],
  'end': [1533, 2571, 3737, 4747, 5895, 6922]
 },
 {'name': 'SSMU', 
  'start': [1096, 2253, 3170],
  'end': [1923, 2801, 3611]},
 {'name': 'KAEX',
  'start': [1013, 2010, 3398, 4292],
  'end': [1973, 2771, 3864, 4982]
 },
 {'name': 'ZTDU',
  'start': [1177, 2250, 3225, 4132, 5040, 6099],
  'end': [1676, 2682, 3915, 4688, 5723, 6956]
 },
 {'name': 'NQSP',
  'start': [1399, 2377, 3163, 4229],
  'end': [1513, 2589, 3695, 4550]},
 {'name': 'MXWY', 
  'start': [1082, 2052, 3292], 
  'end': [1726, 2581, 3865]
 }
]
```

Για παράδειγμα το 2o exon του γονιδίου VLDZ, ξεκινάει στη θέση 2287 και τελειώνει στη θέση 2727. To μέγεθος του 2ου exon του γονιδίου VLDZ είναι 2727-2287=440.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο. Η παράμετρος θα είναι μία λίστα με την ίδια δομή όπως η λίστα genes (δεν χρειάζεται να το ελέγχετε αυτό. Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι τo όνομα του κάθε γονιδίου και οι τιμές θα είναι το άθροισμα των μηκών των exons του κάθε γονιδίου. Για παράδειγμα θα πρέπει:

```python
print (f(genes)) # Τυπώνει:
{'VLDZ': 1774,
 'SUVM': 2092,
 'AMPM': 2981,
 'ZNYP': 3215,
 'DVLY': 2985,
 'SSMU': 1816,
 'KAEX': 2877,
 'ZTDU': 3717,
 'NQSP': 1179,
 'MXWY': 1746}
```

### Άσκηση 35
Έστω το παρακάτω dictionary:

```python
d = {
 'fwdy': {'yldh': 5, 'ujaw': 16},
 'zeiw': {'oyof': 14, 'wnbt': 4, 'sbzh': 16, 'yoke': 13},
 'mjnf': {'iatr': 12, 'owuc': 13, 'izvb': 12, 'axdk': 8},
 'vpvp': {'pqwe': 2, 'gtil': 19, 'qzjs': 15, 'lrgk': 19},
 'flkz': {'ykfj': 20},
 'vawu': {'anbv': 3, 'jfmq': 11, 'gpet': 11, 'bnru': 17},
 'oyzw': {'mclq': 19},
 'raip': {'jrzs': 4},
 'wxwv': {'vzoa': 16, 'inuw': 9},
 'rfcj': {'bmdi': 8, 'zurf': 2, 'sbcj': 17}
 }
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει ένα set με τα κλειδιά των dictionaries που είναι values του d , των οποία τα values είναι μονά. Για παράδειγμα θα πρέπει:

```python
print (f(d)) # Τυπώνει: 
{'anbv',
 'bnru',
 'gpet',
 'gtil',
 'inuw',
 'jfmq',
 'lrgk',
 'mclq',
 'owuc',
 'qzjs',
 'sbcj',
 'yldh',
 'yoke'}
``` 

### Άσκηση 36
Έστω το παρακάτω dictionary:

```python
d = {
 'fwdy': {'yldh': 5, 'ujaw': 16},
 'zeiw': {'oyof': 14, 'wnbt': 4, 'sbzh': 16, 'yoke': 13},
 'mjnf': {'iatr': 12, 'owuc': 13, 'izvb': 12, 'axdk': 8},
 'vpvp': {'pqwe': 2, 'gtil': 19, 'qzjs': 15, 'lrgk': 19},
 'flkz': {'ykfj': 20},
 'vawu': {'anbv': 3, 'jfmq': 11, 'gpet': 11, 'bnru': 17},
 'oyzw': {'mclq': 19},
 'raip': {'jrzs': 4},
 'wxwv': {'vzoa': 16, 'inuw': 9},
 'rfcj': {'bmdi': 8, 'zurf': 2, 'sbcj': 17}
 }
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με τα κλειδιά του d των οποίων το άθροισμα των τιμών των dictionaries των τιμών της d, είναι μονός. Για παράδειγμα θα πρέπει:

```python
print (f(d)) # Τυπώνει: ['fwdy', 'zeiw', 'mjnf', 'vpvp', 'oyzw', 'wxwv', 'rfcj']
```

### Άσκηση 37
Έστω το παρακάτω dictionary:

```python
d = {
 'fwdy': {'yldh': 5, 'ujaw': 16},
 'zeiw': {'oyof': 14, 'wnbt': 4, 'sbzh': 16, 'yoke': 13},
 'mjnf': {'iatr': 12, 'owuc': 13, 'izvb': 12, 'axdk': 8},
 'vpvp': {'pqwe': 2, 'gtil': 19, 'qzjs': 15, 'lrgk': 19},
 'flkz': {'ykfj': 20},
 'vawu': {'anbv': 3, 'jfmq': 11, 'gpet': 11, 'bnru': 17},
 'oyzw': {'mclq': 19},
 'raip': {'jrzs': 4},
 'wxwv': {'vzoa': 16, 'inuw': 9},
 'rfcj': {'bmdi': 8, 'zurf': 2, 'sbcj': 17}
 }
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με τα κλειδιά του d των οποίων το dictionary των values του περιέχει στα values του μόνο μονές τιμές. Για παράδειγμα θα πρέπει:

```python
print (f(d)) # Τυπώνει: ['vawu', 'oyzw'] 
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε την `all`.

### Άσκηση 38
Έστω το παρακάτω dictionary:

```python
d = {
 'fwdy': {'yldh': 5, 'ujaw': 16},
 'zeiw': {'oyof': 14, 'wnbt': 4, 'sbzh': 16, 'yoke': 13},
 'mjnf': {'iatr': 12, 'owuc': 13, 'izvb': 12, 'axdk': 8},
 'vpvp': {'pqwe': 2, 'gtil': 19, 'qzjs': 15, 'lrgk': 19},
 'flkz': {'ykfj': 20},
 'vawu': {'anbv': 3, 'jfmq': 11, 'gpet': 11, 'bnru': 17},
 'oyzw': {'mclq': 19},
 'raip': {'jrzs': 4},
 'wxwv': {'vzoa': 16, 'inuw': 9},
 'rfcj': {'bmdi': 8, 'zurf': 2, 'sbcj': 17}
 }
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιστρέφει μία λίστα με τα κλειδιά του d των οποίων το dictionary των values του περιέχει στα values δεν περιέχουν καμία μονή τιμή. Για παράδειγμα θα πρέπει:

```python
print (f(d)) # Τυπώνει: ['flkz', 'raip'] 
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε την `any`.

### Άσκηση 39 
Έστω το παρακάτω dictionary:

```python
d = {
 'fwdy': {'yldh': 5, 'ujaw': 16},
 'zeiw': {'oyof': 14, 'wnbt': 4, 'sbzh': 16, 'yoke': 13},
 'mjnf': {'iatr': 12, 'owuc': 13, 'izvb': 12, 'axdk': 8},
 'vpvp': {'pqwe': 2, 'gtil': 19, 'qzjs': 15, 'lrgk': 19},
 'flkz': {'ykfj': 20},
 'vawu': {'anbv': 3, 'jfmq': 11, 'gpet': 11, 'bnru': 17},
 'oyzw': {'mclq': 19},
 'raip': {'jrzs': 4},
 'wxwv': {'vzoa': 16, 'inuw': 9},
 'rfcj': {'bmdi': 8, 'zurf': 2, 'sbcj': 17}
 }
```


Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το d (δεν χρειάζεται να το ελέγχετε αυτό). H συνάρτηση θα επιστρέφει ένα dictionary με τα ζευγάρια κλειδιά / τιμές των valus του d, όπου οι τιμές είναι μονές. Για παράδειγμα θα πρέπει:
```python
print (f(d)) # Τυπώνει:
{'yldh': 5,
 'yoke': 13,
 'owuc': 13,
 'gtil': 19,
 'qzjs': 15,
 'lrgk': 19,
 'anbv': 3,
 'jfmq': 11,
 'gpet': 11,
 'bnru': 17,
 'mclq': 19,
 'inuw': 9,
 'sbcj': 17}
``` 

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε dictionary comprehension

### Άσκηση 40 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρους 2 λίστες a,b. Η κάθε λίστα θα περιέχει tuples από 2 αριθμούς, όπου ο πρώτος αριθμός θα είναι μικρότερος του δεύτερου (δεν χρειάζεται να τα ελέγχετε αυτά). Η συνάρτηση θα επιστρέφει το σύνολο των αριθμών από το 1 μέχρι το 100 που ανήκουν σε τουλάχιστον 1 από τα (κλειστά) διαστήματα που ορίζονται από τα tuples της λίστας a, αλλά σε κανένα από τα (κλειστά) διαστήματα που ανήκουν στα tuples της λίστας b. Για παράδειγμα θα πρέπει:

```python
a = [(5, 15), (20, 25), (30, 35)]
b = [(7,22), (25, 34)]

print (f(a,b)) # Τυπώνει {5,6,23,24,35}
```

Hint: Ένωση / τομή συνόλων...

### Άσκηση 41
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από strings (δεν χρειάζεται να το ελέγχετε αυτό). Η συνάρτηση θα επιτρέφει τη λίστα ταξινομημένη σύμφωνα με την.. αλφαβητική ταξινόμηση του κάθε string της λίστας. Για παράδειγμα έστω η λίστα:

```python
l = ['be', 'tc', 'ka']
```

 Αν ταξινομήσουμε αλφαβητικά τον κάθε χαρακτήρα του κάθε string της λίστας θα έχουμε την εξής λίστα:
 ```python
k = ['be', 'ct', 'ak'] # Είναι τα ίδια στοιχεία με την l αλλά κάθε στοιχείο είναι ταξινομημένο αλφαβητικά
 ```

Αν ταξινομήσουμε την k θα έχουμε:

```python
o = ['ak', 'be', 'ct']
```

Αν ταξινομήσουμε την l ανάλογα με τη θέση του κάθε στοιχείου στην o, θα πάρουμε τη λίστα:
```python
n = ['ka', 'be', 'tc']
```

Άρα θα πρέπει:
```python
print (f(l)) #  Τυπώνει: ['ka', 'be', 'tc']
```

Ένα άλλο παράδεγιμα:
```python
l = ['cbc', 'adb', 'dab', 'acb', 'bbc', 'aca', 'bbb', 'aab', 'cad', 'bba']

print (f(l)) # Τυπώνει: ['aab', 'aca', 'bba', 'acb', 'adb', 'dab', 'cad', 'bbb', 'bbc', 'cbc'] 
```

### Άσκηση 42
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία ακολουθία από ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει  τη θέση του αριθμού ο οποίος απέχει λιγότερο από τους γειτονικούς του. Δηλαδή αν η παράμετρος μας είναι η λίστα: α<sub>1</sub>, α<sub>2</sub>, ..., α<sub>i</sub>, ... α<sub>n</sub>, τότε θα πρέπει να βρείτε τον αριθμό i τέτοιον ώστε η έκφραση |α<sub>i-1</sub>-α<sub>i</sub>|+|α<sub>i</sub>-α<sub>i+1</sub>| να είναι η μικρότερη για όλα τα δυνατά i. Προφανώς το i δεν μπορεί να είναι 0 ή n. Δίνεται ένα παράδειγμα:

Δίνεται η λίστα:
```python
l = [78, 14, 11, 45, 87, 43, 58, 52, 49, 63, 50, 31, 72, 34, 32, 10, 17, 67, 7, 53]
````
Θα πρέπει:
```python
print (f(l)) # Τυπώνει: 7
```

Εξήγηση:
Ο 6ος, 7oς και 8ος αριθμός είναι:
```python
print (l[6], l[7], l[8]) # 58 52 49 
``` 

To άθροισμα: |52-58| + |52-49| είναι 9 και είναι το μικρότερο, για όλες τις συνεχόμενες τριάδες του l. 

Σημείωση: το απόλυτο ενός αριθμού υπολογίζεται με τη συνάρτηση: `abs`.

### Άσκηση 43
Δίνεται η παρακάτω συνάρτηση η οποία μετατρέπει έναν οποιοδήποτε ακέραιο αριθμό από το 1 μέχρι και το 3999 σε λατινική μορφή:
```python
def int_to_roman(num):
  
    # Storing roman values of digits from 0-9
    # when placed at different places
    m = ["", "M", "MM", "MMM"]
    c = ["", "C", "CC", "CCC", "CD", "D",
         "DC", "DCC", "DCCC", "CM"]
    x = ["", "X", "XX", "XXX", "XL", "L",
         "LX", "LXX", "LXXX", "XC"]
    i = ["", "I", "II", "III", "IV", "V",
         "VI", "VII", "VIII", "IX"]
  
    # Converting to roman
    thousands = m[num // 1000]
    hundreds = c[(num % 1000) // 100]
    tens = x[(num % 100) // 10]
    ones = i[num % 10]
  
    ans = (thousands + hundreds +
           tens + ones)
  
    return ans
```

Τη συνάρτηση τη βρήκα [εδώ](https://www.geeksforgeeks.org/python-program-to-convert-integer-to-roman/). Ποιος είναι ο αριθμός από το 1 μέχρι και το 4999 του οποίου η λατινική αναπαράσταση έχει τα περισσότερα γράμματα; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση σε αυτή την ερώτηση. 

### Άσκηση 44 
Έστω 2 ευθείες γραμμές:
* y<sub>1</sub> = a<sub>1</sub>x + b<sub>1</sub>
* y<sub>2</sub> = a<sub>2</sub>x + b<sub>2</sub>

Δύο ευθείες y<sub>1</sub>, y<sub>2</sub> είναι παράλληλες αν ισχύει: a<sub>1</sub>=a<sub>2</sub>. Επίσης αν οι y<sub>1</sub>, y<sub>2</sub> είναι παράλληλες τότε η απόστασή τους είναι d = |b<sub>1</sub>-b<sub>2</sub>|/√(a<sup>2</sup>+1). [πηγή](https://en.wikipedia.org/wiki/Distance_between_two_parallel_lines). Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με tuples. Κάθε tuple θά έχει 2 αριθμούς οι οποίοι θα αντιστοιχούν στις παραμέτρους α,β μίας ευθείας. Η συνάρτηση θα πρέπει:
* Να υπολογίζει όλα τα ζευγάρια από ευθείες οι οποίες είναι παράλληλες μεταξύ τους.
* Για κάθε ζευγάρι παράλληλων ευθειών να υπολογίζει την μεταξύ τους απόσταση.
* Επιστρέφει τη μικρότερη απόσταση. 

Δίνεται ένα παράδειγμα:
```python
l = [
 (1, 96),
 (2, 92),
 (1, 11),
 (1, 25),
 (1, 90),
 (3, 41),
 (3, 75),
 (2, 37),
 (1, 43),
 (3, 68),
 (1, 32),
 (2, 4),
 (3, 25),
 (2, 2),
 (2, 70),
 (1, 98),
 (3, 51),
 (3, 65),
 (2, 52),
 (2, 85).
]

print (f(l)) # Τυπώνει: 0.8944271909999159 
```

### Άσκηση 45 
Στη Eurovision μία χώρα μπορεί να δώσει πόντους σε 10 άλλες χώρες. Οι πόντοι που μπορεί να δώσει είναι 1,2,3,4,5,6,7,8,10 ή 12. Στο τέλος υπάρχει το εξής κριτήριο για να βρεθεί ο νικητής:
* Νικητής είναι η χώρα που έχει τους περισσότερους βαθμούς.
* Αν υπάρχουν 2 ή περισσότερες χώρες με τον ίδιο βαθμό, νικητής είναι η χώρα με τα περισσότερα 12-άρια. 
* Αν υπάρχουν 2 ή περισσότερες χώρες με τα ίδια 12-άρια, νικητής είναι η χώρα με τα περισσότερα 10-άρια. 
* Αν υπάρχουν 2 ή περισσότερες χώρες με τα ίδια 10-άρια, νικητής είναι η χώρα με τα περισσότερα 8-άρια. 
* Αν υπάρχουν 2 ή περισσότερες χώρες με τα ίδια 8-άρια, νικητής είναι η χώρα με τα περισσότερα 7-άρια. 
* ...


Μία χρονιά πήραν μέρος στον τελικό μόνο 10 χώρες, ενώ ψήφισαν 50 χώρες. Οι πόντοι που πήρε η κάθε μία από τις 10 χώρες είναι:
```python
points = {
    'Country_1': [2, 4, 1, 7, 10, 7, 12, 7, 2, 10, 12, 10, 6, 7, 6, 5, 5, 5, 1, 7, 12, 10, 10, 12, 12, 3, 3, 3, 3, 2, 12, 7, 2, 8, 8, 6, 12, 7, 4, 2, 8, 7, 1, 6, 4], 
     'Country_2': [8, 1, 8, 4, 7, 8, 3, 5, 7, 4, 1, 8, 10, 12, 2, 5, 1, 8, 8, 2, 4, 12, 2, 3, 5, 5, 10, 4, 12, 2, 4, 8, 8, 10, 1, 4, 7, 4, 3, 12, 1, 4, 10, 4, 10, 6, 4, 5, 8, 6], 
     'Country_3': [10, 6, 7, 12, 2, 5, 2, 5, 8, 3, 8, 10, 7, 2, 1, 4, 1, 4, 1, 2, 4, 4, 12, 4, 2, 12, 1, 10, 3, 5, 12, 1, 2, 6, 8, 8, 8, 1, 3, 10, 12, 12, 5, 2, 3, 2, 5, 3, 4, 7, 8, 5, 2, 4], 
     'Country_4': [2, 5, 1, 7, 2, 12, 2, 6, 3, 10, 4, 3, 8, 6, 1, 6, 2, 7, 10, 7, 7, 5, 3, 7, 8, 12, 12, 5, 2, 8, 7, 10, 6, 7, 4, 12, 1, 8, 8, 10, 4, 6, 6, 12, 3, 1, 4, 8], 
     'Country_5': [2, 2, 3, 3, 6, 5, 10, 10, 8, 10, 6, 6, 8, 4, 7, 10, 3, 5, 2, 7, 8, 5, 12, 4, 3, 10, 12, 2, 6, 3, 6, 4, 6, 12, 1, 2, 10, 6, 2, 7, 6, 2, 2, 2, 12, 7, 12, 5, 3, 1], 
     'Country_6': [5, 8, 4, 1, 10, 5, 5, 7, 5, 4, 10, 4, 10, 7, 3, 3, 5, 5, 4, 6, 3, 6, 3, 4, 6, 3, 3, 4, 10, 1, 1, 10, 6, 3, 1, 1, 6, 3, 6, 2, 8, 6, 5, 12, 10, 8, 1, 3, 4, 8, 7, 5, 8, 1, 5, 6], 
     'Country_7': [12, 5, 10, 12, 3, 4, 8, 3, 2, 1, 1, 3, 3, 12, 7, 4, 7, 1, 7, 12, 5, 10, 1, 5, 5, 10, 6, 7, 2, 12, 6, 10, 2, 3, 5, 1, 12, 8, 3, 6, 1, 7, 1, 10, 8, 12, 6, 7, 2], 
     'Country_8': [5, 8, 4, 3, 7, 7, 4, 4, 1, 4, 10, 8, 6, 12, 12, 3, 1, 7, 8, 5, 4, 12, 10, 7, 4, 3, 1, 2, 2, 7, 7, 1, 5, 1, 7, 3, 3, 12, 2, 1, 3, 8, 7, 10, 6, 7, 1, 10, 10, 4, 4, 6, 1], 
     'Country_9': [4, 10, 6, 8, 8, 2, 8, 12, 5, 7, 1, 1, 7, 12, 2, 12, 5, 3, 6, 5, 12, 3, 10, 12, 3, 3, 7, 10, 1, 6, 6, 6, 3, 6, 4, 5, 1, 7, 12, 1, 5, 10, 6, 10, 5, 12], 
     'Country_10': [6, 4, 10, 1, 1, 2, 10, 12, 5, 8, 6, 10, 2, 8, 5, 8, 5, 6, 8, 6, 2, 4, 5, 3, 2, 8, 12, 8, 2, 12, 12, 6, 8, 5, 3, 2, 8, 2, 10, 7, 6, 4, 4, 2, 10, 5, 7, 1, 7],
}
```



Προσθέτοντας τους πόντους κάθε χώρας η επιτροπή βλέπει με τρόμο ότι όλες οι χώρες έχουν ισοψηφίσει!
```python
for k,v in points.items():
    print (f'Η χώρα {k} πήρε {sum(v)} πόντους' )
```

Ευτυχώς εσείς είστε μέλος της επιτροπής που με τη τρομερή python που ξέρετε θα βρείτε τον νικητή σύμφωνα με τους κανόνες που δόθηκαν παραπάνω. Φτιάξτε λοιπόν μία συνάρτηση η οποία θα έχει την ίδια δομή όπως το dictionary `points`. Η συνάρτηση θα επιστρέφει ένα string με το όνομα της χώρας που έχει νικήσει. 

### Άσκηση 45.5 (ναι.. γιατί όχι;;, προαιρετική για.. μερακλήδες)
Διαβάζοντας την εκφώνηση της άσκησης 45 κάποιος μπορεί να αναρωτηθεί: πως παράχθηκε το dictionary `points`; Ψήφισαν 50 χώρες και κάθε χώρα έδωσε ένα 1-άρι, ένα 2-άρι, ένα 3-άρι, ένα 4-άρι, ένα 5-άρι, ένα 6-άρι, ένα 7-άρι, ένα 8-άρι, ένα 10-άρι και ένα 12-άρι. Άρα όλοι οι βαθμοί που δόθηκαν είναι:

```python
all_points = [y for x in range(50) for y in [1,2,3,4,5,6,7,8,10,12]]
``` 

Η κάθε χώρα έδωσε: `sum([1,2,3,4,5,6,7,8,10,12]) = 58`

Η `all_points` έχει συνολικά 2900 βαθμούς (58\*50). Μπορείτε να χωρίσετε όλους αυτούς τους βαθμούς σε 10 τυχαίες διαφορετικές λίστες έτσι ώστε κάθε λίστα να έχει άθροισμα 290;

Δίνεται η παρακάτω συνάρτηση η οποία ανακατεύει τυχαία μία λίστα:
```python
import random

a = [1,2,3,4,5]
random.shuffle(a)
print (a)
```

Δίνεται επίσης η παρακάτω συνάρτηση η οποία επιστρέφει έναν τυχαίο αριθμό από το 1 μέχρι *και* το 10:
```python
r = random.randint(1,10)
print (r)
```

Φτιάξτε μια συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει τυχαίες απαντήσεις στην ερώτηση που τέθηκε. Δίνω μερικά παραδείγματα:

```python

print (f()) 
#   Τυπώνει:
[
    [10, 1, 3, 1, 12, 6, 7, 3, 3, 12, 8, 1, 12, 5, 3, 12, 3, 1, 8, 8, 2, 10, 5, 3, 5, 6, 2, 2, 7, 6, 6, 10, 6, 7, 7, 12, 3, 5, 2, 7, 8, 12, 1, 8, 3, 4, 7, 5, 7, 3], 
    [5, 2, 2, 6, 2, 10, 8, 3, 7, 4, 8, 8, 2, 6, 3, 6, 8, 10, 7, 6, 5, 7, 12, 3, 3, 8, 5, 12, 12, 12, 1, 7, 8, 8, 8, 1, 7, 5, 3, 7, 5, 2, 7, 12, 3, 12, 2], 
    [7, 6, 4, 1, 12, 10, 3, 1, 3, 8, 5, 3, 12, 4, 2, 8, 5, 1, 7, 5, 12, 6, 7, 5, 4, 5, 4, 8, 3, 8, 7, 10, 2, 4, 12, 5, 7, 1, 4, 12, 12, 10, 4, 2, 4, 8, 2, 3, 10, 2], 
    [10, 3, 1, 8, 4, 5, 7, 3, 7, 1, 3, 4, 12, 3, 7, 2, 1, 1, 4, 3, 1, 1, 2, 4, 1, 6, 8, 5, 6, 5, 8, 8, 12, 8, 7, 4, 2, 1, 4, 5, 7, 2, 6, 5, 4, 3, 1, 12, 12, 1, 3, 8, 7, 8, 12, 12], 
    [10, 1, 6, 1, 6, 3, 4, 2, 5, 1, 8, 5, 3, 7, 8, 8, 5, 1, 12, 2, 6, 1, 2, 6, 12, 6, 2, 7, 1, 1, 5, 12, 10, 5, 2, 7, 8, 5, 4, 2, 12, 4, 8, 1, 12, 6, 7, 4, 1, 6, 3, 4, 10, 8, 2], 
    [6, 1, 4, 2, 5, 10, 6, 1, 10, 12, 10, 5, 2, 2, 5, 4, 4, 4, 3, 8, 10, 12, 4, 10, 1, 10, 10, 7, 6, 6, 12, 3, 12, 1, 6, 2, 5, 4, 5, 5, 4, 4, 3, 10, 8, 12, 4, 2, 2, 6], 
    [8, 5, 6, 6, 10, 1, 2, 2, 12, 10, 3, 4, 1, 8, 1, 5, 5, 2, 6, 4, 10, 6, 10, 10, 10, 7, 5, 7, 10, 10, 2, 7, 3, 4, 8, 12, 2, 10, 6, 12, 6, 1, 10, 7, 4, 10], 
    [4, 1, 2, 6, 4, 5, 8, 3, 5, 1, 7, 8, 7, 10, 5, 4, 10, 6, 1, 6, 3, 10, 7, 8, 2, 12, 3, 4, 6, 10, 3, 5, 2, 12, 6, 1, 8, 7, 2, 7, 8, 10, 4, 3, 7, 12, 7, 10, 7, 1], 
    [6, 3, 6, 12, 1, 7, 3, 5, 12, 3, 6, 10, 7, 8, 2, 1, 12, 1, 8, 5, 3, 6, 3, 5, 2, 4, 7, 2, 7, 4, 12, 6, 8, 4, 3, 10, 12, 4, 10, 10, 10, 7, 2, 6, 2, 4, 5, 7, 7], 
    [8, 8, 6, 10, 10, 12, 6, 4, 2, 5, 1, 12, 12, 3, 8, 12, 4, 1, 3, 7, 4, 8, 10, 3, 6, 10, 1, 8, 6, 4, 5, 3, 10, 4, 10, 8, 6, 5, 12, 1, 6, 2, 5, 5, 2, 2, 10],
]


print (f()) 
# Τυπώνει:
[
    [8, 1, 2, 8, 5, 7, 10, 7, 12, 2, 12, 4, 12, 3, 12, 7, 4, 1, 12, 2, 12, 3, 8, 2, 2, 10, 4, 3, 4, 4, 6, 8, 6, 7, 7, 5, 8, 4, 3, 1, 2, 2, 12, 4, 2, 10, 5, 2, 2, 3, 7, 1], 
    [7, 3, 6, 4, 6, 10, 12, 8, 12, 10, 5, 4, 10, 4, 5, 6, 4, 5, 6, 3, 6, 8, 4, 1, 10, 2, 3, 5, 3, 12, 3, 10, 5, 10, 7, 2, 1, 12, 10, 4, 12, 3, 5, 6, 8, 7, 1], 
    [7, 4, 6, 6, 10, 8, 6, 5, 12, 2, 1, 8, 2, 1, 4, 1, 2, 3, 7, 2, 8, 10, 4, 3, 5, 10, 12, 10, 1, 4, 4, 5, 5, 6, 10, 4, 6, 4, 2, 8, 12, 7, 4, 7, 8, 5, 1, 1, 10, 4, 10, 3], 
    [2, 12, 6, 5, 6, 8, 10, 5, 1, 2, 6, 5, 4, 10, 12, 6, 8, 5, 8, 3, 2, 4, 1, 4, 6, 2, 8, 2, 3, 2, 3, 1, 10, 7, 7, 5, 10, 4, 2, 5, 4, 8, 6, 12, 5, 4, 8, 7, 1, 6, 10, 7], 
    [1, 1, 1, 5, 5, 8, 5, 10, 10, 1, 1, 12, 5, 5, 4, 6, 5, 1, 6, 12, 6, 3, 7, 1, 8, 7, 8, 3, 12, 3, 4, 7, 4, 4, 10, 4, 12, 1, 12, 4, 7, 1, 8, 7, 7, 5, 3, 1, 7, 1, 3, 8, 1, 7], 
    [4, 3, 1, 7, 5, 8, 3, 6, 1, 6, 8, 8, 6, 10, 1, 3, 8, 3, 12, 7, 1, 8, 10, 10, 1, 1, 12, 6, 7, 1, 3, 4, 7, 2, 12, 6, 5, 7, 12, 8, 1, 12, 4, 6, 12, 5, 6, 1, 10], 
    [6, 8, 6, 8, 5, 7, 12, 5, 12, 5, 6, 4, 12, 8, 1, 2, 12, 12, 8, 6, 10, 3, 3, 5, 1, 10, 7, 2, 3, 7, 8, 4, 5, 3, 1, 5, 2, 7, 3, 8, 12, 10, 12, 7, 7], 
    [8, 12, 7, 5, 2, 2, 12, 2, 2, 2, 5, 6, 1, 6, 8, 5, 12, 7, 6, 2, 4, 3, 12, 2, 3, 8, 2, 4, 12, 5, 3, 7, 3, 2, 5, 3, 12, 1, 12, 8, 4, 2, 6, 4, 10, 10, 7, 2, 8, 4, 8, 2], 
    [2, 4, 4, 3, 1, 6, 2, 10, 1, 7, 10, 3, 8, 10, 7, 7, 1, 2, 3, 7, 3, 10, 5, 1, 6, 6, 1, 3, 7, 6, 3, 7, 4, 8, 6, 3, 3, 2, 12, 6, 5, 12, 3, 12, 2, 5, 8, 10, 5, 10, 8, 10], 
    [2, 7, 10, 3, 8, 2, 10, 6, 6, 12, 5, 10, 7, 12, 10, 10, 3, 8, 3, 2, 1, 8, 10, 3, 1, 5, 7, 10, 4, 12, 6, 12, 5, 5, 8, 7, 4, 10, 6, 2, 4, 6, 6, 2, 10],
]


print (f())
# Τυπώνει:
[
    [10, 8, 2, 1, 3, 12, 6, 12, 7, 1, 4, 3, 3, 6, 6, 2, 6, 3, 2, 2, 10, 8, 8, 10, 2, 2, 10, 8, 7, 7, 4, 5, 12, 8, 5, 10, 7, 6, 3, 7, 3, 4, 3, 8, 8, 3, 12, 4, 5, 1, 1], 
    [8, 7, 8, 2, 4, 8, 5, 7, 10, 12, 7, 8, 2, 1, 1, 7, 8, 4, 6, 12, 5, 10, 2, 10, 8, 6, 4, 1, 8, 6, 10, 2, 5, 3, 4, 3, 2, 5, 8, 1, 7, 10, 4, 12, 3, 6, 8, 7, 3], 
    [2, 5, 2, 7, 10, 7, 6, 5, 12, 7, 5, 3, 5, 8, 12, 7, 2, 10, 3, 10, 5, 12, 2, 8, 6, 6, 10, 2, 6, 4, 5, 1, 6, 4, 8, 6, 4, 12, 6, 1, 4, 3, 10, 12, 2, 2, 7, 8], 
    [6, 12, 12, 1, 5, 1, 5, 12, 3, 3, 1, 4, 7, 1, 3, 6, 5, 10, 5, 6, 4, 7, 4, 10, 2, 8, 8, 10, 10, 10, 6, 7, 2, 3, 4, 6, 5, 10, 1, 6, 12, 2, 8, 12, 3, 12, 3, 7], 
    [5, 6, 5, 12, 2, 5, 8, 3, 4, 10, 1, 8, 12, 3, 1, 3, 2, 5, 3, 1, 10, 5, 6, 10, 1, 2, 12, 6, 6, 7, 10, 5, 7, 10, 8, 12, 12, 2, 2, 6, 12, 1, 6, 3, 5, 12, 4, 8, 1], 
    [6, 2, 12, 4, 8, 3, 2, 7, 7, 12, 12, 4, 7, 1, 7, 7, 1, 12, 12, 8, 3, 10, 6, 1, 10, 4, 6, 6, 2, 7, 12, 6, 5, 5, 7, 10, 7, 8, 5, 4, 1, 6, 12, 4, 8, 1], 
    [4, 7, 8, 3, 5, 3, 4, 3, 2, 1, 4, 8, 5, 6, 4, 10, 4, 4, 5, 3, 5, 2, 6, 10, 2, 12, 5, 6, 5, 12, 12, 7, 3, 10, 8, 8, 5, 1, 10, 8, 3, 12, 12, 10, 6, 2, 1, 6, 4, 3, 1], 
    [8, 1, 5, 1, 12, 8, 8, 1, 1, 3, 1, 4, 3, 5, 12, 5, 1, 10, 10, 12, 4, 7, 12, 8, 12, 10, 4, 3, 7, 7, 2, 5, 8, 10, 10, 10, 7, 12, 12, 7, 5, 2, 3, 12],
    [12, 4, 1, 4, 6, 2, 12, 4, 5, 3, 4, 5, 1, 3, 6, 6, 6, 12, 1, 7, 4, 7, 10, 8, 4, 6, 3, 2, 10, 2, 4, 7, 7, 12, 10, 2, 6, 8, 2, 10, 8, 5, 8, 1, 2, 3, 2, 3, 8, 2, 5, 3, 8, 4], 
    [6, 8, 2, 3, 10, 5, 1, 7, 2, 1, 4, 5, 7, 1, 5, 3, 4, 8, 4, 7, 4, 3, 7, 10, 7, 5, 6, 1, 4, 2, 4, 10, 6, 6, 4, 5, 1, 6, 1, 2, 3, 2, 10, 7, 1, 10, 1, 8, 7, 12, 10, 7, 4, 1, 7, 2, 5, 1, 3, 2],
]

```

### Άσκηση 46 

Σε αυτή τη σελίδα: https://en.wikipedia.org/wiki/List_of_cities_and_towns_in_Greece Υπάρχει ένας πίνακας με τον πληθυσμό των Ελληνικών πόλεων.

Ο πίνακας αυτός σε μορφή dictionary είναι:

```python
cities = {
 'Athens': [772072, 745514, 664046, 'Attica'],
 'Thessaloniki': [383967, 363987, 315196, 'Central Macedonia'],
 'Patras': [152570, 160400, 167446, 'Western Greece'],
 'Piraeus': [182671, 175697, 163688, 'Attica'],
 'Larissa': [112777, 124394, 144651, 'Thessaly'],
 'Heraklion': [115270, 130914, 140730, 'Crete'],
 'Peristeri': [137288, 137918, 139981, 'Attica'],
 'Kallithea': [194233, 109609, 100641, 'Attica'],
 'Acharnes': [61052, 75329, 99346, 'Attica'],
 'Kalamaria': [80698, 87255, 91279, 'Central Macedonia'],
 'Nikaia': [87597, 93086, 89380, 'Attica'],
 'Glyfada': [63306, 80409, 87305, 'Attica'],
 'Volos': [77192, 82439, 86046, 'Thessaly'],
 'Ilio': [78326, 80859, 84793, 'Attica'],
 'Ilioupoli': [75037, 75904, 78153, 'Attica'],
 'Keratsini': [71982, 76102, 77077, 'Attica'],
 'Evosmos': [28821, 52624, 74686, 'Central Macedonia'],
 'Chalandri': [66285, 71684, 74192, 'Attica'],
 'Nea Smyrni': [69749, 73986, 73076, 'Attica'],
 'Marousi': [64092, 69470, 72333, 'Attica'],
 'Agios Dimitrios': [57574, 65173, 71294, 'Attica'],
 'Zografou': [80492, 76115, 71026, 'Attica'],
 'Egaleo': [78563, 74046, 69946, 'Attica'],
 'Nea Ionia': [27904, 30804, 32661, 'Thessaly'],
 'Ioannina': [56699, 61629, 65574, 'Epirus'],
 'Palaio Faliro': [61371, 64759, 64021, 'Attica'],
 'Korydallos': [63184, 67456, 63445, 'Attica'],
 'Trikala': [45835, 48686, 61653, 'Thessaly'],
 'Vyronas': [58523, 61102, 61308, 'Attica'],
 'Agia Paraskevi': [47463, 56836, 59704, 'Attica'],
 'Galatsi': [57230, 58042, 59345, 'Attica'],
 'Agrinio': [52081, 54523, 59329, 'Western Greece'],
 'Chalcis': [51646, 53584, 59125, 'Central Greece'],
 'Petroupoli': [38278, 48327, 58979, 'Attica'],
 'Serres': [50017, 54266, 58287, 'Central Macedonia'],
 'Alexandroupoli': [37904, 48885, 57812, 'Eastern Macedonia and Thrace'],
 'Xanthi': [37430, 45111, 56122, 'Eastern Macedonia and Thrace'],
 'Katerini': [43613, 50510, 55997, 'Central Macedonia'],
 'Kalamata': [43625, 49154, 54100, 'Peloponnese'],
 'Kavala': [56571, 58663, 54027, 'Eastern Macedonia and Thrace'],
 'Chania': [50077, 53373, 53910, 'Crete'],
 'Lamia': [44084, 46406, 52006, 'Central Greece'],
 'Komotini': [37036, 43326, 50990, 'Eastern Macedonia and Thrace'],
 'Irakleio': [42905, 45926, 49642, 'Attica'],
 'Rhodes': [42400, 52318, 49541, 'South Aegean'],
 'Kifissia': [39166, 43929, 47332, 'Attica'],
 'Stavroupoli': [37596, 41653, 46008, 'Central Macedonia'],
 'Chaidari': [44831, 45227, 45642, 'Attica'],
 'Drama': [37604, 42501, 44823, 'Eastern Macedonia and Thrace'],
 'Veria': [37858, 42794, 43158, 'Central Macedonia'],
 'Alimos': [32024, 38047, 41720, 'Attica'],
 'Kozani': [31553, 35242, 41066, 'Western Macedonia'],
 'Polichni': [27894, 36146, 39332, 'Central Macedonia'],
 'Karditsa': [30067, 32031, 38554, 'Thessaly'],
 'Sykies': [34059, 41726, 37753, 'Central Macedonia'],
 'Ampelokipoi': [40093, 40959, 37381, 'Central Macedonia'],
 'Pylaia': [20785, 22744, 34625, 'Central Macedonia'],
 'Agioi Anargyroi': [30739, 32957, 34168, 'Attica'],
 'Argyroupoli': [31530, 33158, 34097, 'Attica'],
 'Ano Liosia': [21397, 26423, 33565, 'Attica'],
 'Rethymno': [23420, 27868, 32468, 'Crete'],
 'Ptolemaida': [25125, 28679, 32127, 'Western Macedonia'],
 'Tripoli': [22429, 25520, 30866, 'Peloponnese'],
 'Cholargos': [33691, 32166, 30840, 'Attica'],
 'Vrilissia': [16571, 25582, 30741, 'Attica'],
 'Aspropyrgos': [15715, 27741, 30251, 'Attica'],
 'Corinth': [27412, 29787, 30176, 'Peloponnese'],
 'Gerakas': [8512, 13921, 29939, 'Attica'],
 'Metamorfosi': [21052, 26448, 29891, 'Attica'],
 'Giannitsa': [22504, 26296, 29789, 'Central Macedonia'],
 'Voula': [17998, 25532, 28364, 'Attica'],
 'Kamatero': [17410, 22234, 28361, 'Attica'],
 'Mytilene': [23971, 27247, 27871, 'North Aegean'],
 'Neapoli': [30568, 29995, 27084, 'Central Macedonia'],
 'Eleftherio-Kordelio': [16549, 21630, 27067, 'Central Macedonia'],
 'Chios': [22894, 23779, 26850, 'North Aegean'],
 'Agia Varvara': [28706, 30562, 26550, 'Attica'],
 'Kaisariani': [26701, 26323, 26370, 'Attica'],
 'Nea Filadelfeia': [25261, 24112, 25734, 'Attica'],
 'Moschato': [22039, 23153, 25441, 'Attica'],
 'Perama': [24119, 25720, 25389, 'Attica'],
 'Salamina': [22567, 25730, 25370, 'Attica'],
 'Eleusis': [22793, 25863, 24910, 'Attica'],
 'Corfu': [31359, 28185, 24838, 'Ionian Islands'],
 'Pyrgos': [28465, 23274, 24359, 'Western Greece'],
 'Megara': [20403, 23032, 23456, 'Attica'],
 'Kilkis': [12139, 17430, 22914, 'Central Macedonia'],
 'Dafni': [24152, 23674, 22913, 'Attica'],
 'Thebes': [19505, 21211, 22883, 'Central Greece'],
 'Melissia': [13469, 19526, 22741, 'Attica'],
 'Argos': [21901, 24239, 22209, 'Peloponnese'],
 'Arta': [19087, 19435, 21895, 'Epirus'],
 'Artemida': [9485, 17391, 21488, 'Attica'],
 'Livadeia': [18437, 20061, 21379, 'Central Greece'],
 'Pefki': [17987, 19887, 21352, 'Attica'],
 'Oraiokastro': [5458, 11896, 20852, 'Central Macedonia'],
 'Aigio': [22178, 21061, 20422, 'Western Greece'],
 'Kos': [14714, 17890, 19432, 'South Aegean'],
 'Koropi': [12790, 15860, 19164, 'Attica'],
 'Preveza': [13695, 16321, 19042, 'Epirus'],
 'Naousa': [19794, 19870, 18882, 'Central Macedonia'],
 'Orestiada': [12691, 15246, 18426, 'Eastern Macedonia and Thrace'],
 'Peraia': [2949, 13306, 18326, 'Central Macedonia'],
 'Edessa': [17128, 18253, 18229, 'Central Macedonia'],
 'Florina': [12355, 14279, 17686, 'Western Macedonia'],
 'Panorama': [10275, 14552, 17444, 'Central Macedonia'],
 'Nea Erythraia': [12993, 15439, 17379, 'Attica'],
 'Elliniko': [13517, 16740, 17259, 'Attica'],
 'Amaliada': [15232, 18261, 16763, 'Western Greece'],
 'Pallini': [8021, 12552, 16415, 'Attica'],
 'Sparta': [13011, 14817, 16239, 'Peloponnese'],
 'Agios Ioannis Rentis': [14218, 15060, 16050, 'Attica'],
 'Thermi': [5156, 11360, 16004, 'Central Macedonia'],
 'Vari': [8488, 10998, 15855, 'Attica'],
 'Nea Makri': [12120, 13986, 15554, 'Attica'],
 'Tavros': [15456, 14963, 14972, 'Attica'],
 'Alexandreia': [12109, 13229, 14821, 'Central Macedonia'],
 'Menemeni': [12932, 14910, 14746, 'Central Macedonia'],
 'Paiania': [9710, 12855, 14595, 'Attica'],
 'Kalyvia Thorikou': [8488, 12202, 14424, 'Attica'],
 'Nafplio': [11897, 13822, 14203, 'Peloponnese'],
 'Drapetsona': [13094, 12944, 13968, 'Attica'],
 'Efkarpia': [3480, 6598, 13905, 'Central Macedonia'],
 'Papagou': [13974, 13207, 13699, 'Attica'],
 'Nafpaktos': [10854, 12924, 13415, 'Western Greece'],
 'Kastoria': [14775, 14813, 13387, 'Western Macedonia'],
 'Grevena': [9345, 10177, 13137, 'Western Macedonia'],
 'Pefka': [3561, 6434, 13052, 'Central Macedonia'],
 'Nea Alikarnassos': [10683, 11551, 12925, 'Crete'],
 'Missolonghi': [10916, 12225, 12785, 'Western Greece'],
 'Gazi': [1395, 8018, 12606, 'Crete'],
 'Ierapetra': [9541, 11678, 12355, 'Crete'],
 'Kalymnos': [10543, 10149, 12324, 'South Aegean'],
 'Rafina': [7752, 11352, 12168, 'Attica'],
 'Loutraki': [9388, 11383, 11564, 'Peloponnese'],
 'Agios Nikolaos': [8093, 10080, 11421, 'Crete'],
 'Ermoupoli': [13030, 11799, 11407, 'South Aegean'],
 'Ialysos': [7193, 10107, 11331, 'South Aegean'],
 'Mandra': [10012, 10947, 11327, 'Attica'],
 'Tyrnavos': [12028, 11116, 11069, 'Thessaly'],
 'Glyka Nera': [5813, 6623, 11049, 'Attica'],
 'Ymittos': [11671, 11139, 10715, 'Attica'],
 'Neo Psychiko': [12023, 10848, 10137, 'Attica'],
}
```

Σε αυτό το dictionary οι τιμές στις λίστες των τιμών είναι:

* Η 1η είναι ο πληθυσμός της πόλης με βάση την απογραφή του 1991
* Η 2η είναι ο πληθυσμός της πόλης με βάση την απογραφή του 2001
* Η 3η είναι η πληθυσμός της πόλης με βάση την απογραφή του 2011
* Η 4η είναι η περιφέρεια στην οποία ανήκει η πόλη

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary με την ίδια δομή όπως το `cities` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει ένα νέο dictionary όπου τα κλειδιά θα είναι η κάθε περιφέρεια και οι τιμές θα είναι μία λίστα με τις δύο πόλεις που έχουν τον μικρότερο μέσο μέσο όρο πληθυσμών για τις 3 χρονιές: 1991, 2001, 2011.

### Άσκηση 47 
Έστω η παρακάτω λίστα με διαστήματα:
```python
l = [(1, 2), (3, 4), (5, 6), (0, 7), (-1, 5.5)]
``` 

Παρατηρούμε ότι πολλα διαστήματα επικαλύπτονται:
* Το διάστημα (1,2) δεν επικαλύπτει κανένα άλλο διάστημα
* Το διάστημα (3,4) δεν επικαλύπτει κανένα άλλο διάστημα
* Το διάστημα (5,6) δεν επικαλύπτει κανένα άλλο διάστημα
* Το διάστημα (0,7) επικαλύπτει 3 διαστήματα: (1,2), (3,4), (5,6)
* Το διάστημα (-1,5.5) επικαλύπτει 2 διαστήματα: (1,2), (3,4)

Άρα το διάστημα το οποίο επικαλύπτει τα περισσότερα διαστήματα είνα το (0,7).

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με την ίδια δομή όπως η l (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει το διάστημα το οποίο επικαλύπτι το μεγαλύτερο πλήθος από τα υπόλοιπα διαστήματα. Θα πρέπει δηλαδή:

```python
print (f(l)) # Επιστρέφει: (0,7) 
```

Σημείωση: ως επικάλυψη εννοούμε τις αυστηρές ανισότητες (<, >) και όχι <= ή >=. Για παράδειγμα το διάστημα (1,2) δεν επικαλύπτει το διάστημα (1,2). 

### Άσκηση 48
Συμπληρώστε τον παρακάτω κώδικα:

```python
a = lambda ...
```

έτσι ώστε όταν κάνω ```a(x)(y)(z)``` να επιστρέφει τον μέσο όρο των x,y,z. Θα πρέπει δηλαδή:

```python
print (a(2)(4)(9)) # τυπώνει 5.0 
```

### Άσκηση 49

Ταξινομήστε όλους τους αριθμούς n από το 1 μέχρι και το 100 ανάλογα με το άθροισμα των πρώτων 5 δεκαδικών ψηφίων που έχει η έκφραση 1/√n. Για παράδειγμα ο αριθμός 10 έχει 1/√10 = 0.31622776601683794. Τα πρώτα 5 δεκαδικά ψηφία είναι: 31622. Το άθροισμά τους είναι: 3+1+6+2+2 = 14. Ταξινήστε από το μικρότερο προς το μεγαλύτερο άθροισμα. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα επιστρέφει τη λίστα με τους 100 αριθμούς ταξινομημένους όπως περιγράφηκε παραπάνω. 

### Άσκηση 50
Έστω ότι το παρακάτω dictionary έχει τα αθλήματα που πρέπει να διαγωνιστεί κάποιος υποψήφιος για μία γυμναστική ακαδημία:

```python
sports = {
 'sport_1': {'threshold': 21, 'quotient': 9.858},
 'sport_2': {'threshold': 23, 'quotient': 3.558},
 'sport_3': {'threshold': 29, 'quotient': 0.143},
 'sport_4': {'threshold': 24, 'quotient': 2.852},
 'sport_5': {'threshold': 28, 'quotient': 3.461},
 'sport_6': {'threshold': 21, 'quotient': 4.071},
 'sport_7': {'threshold': 27, 'quotient': 3.279},
 'sport_8': {'threshold': 23, 'quotient': 8.091},
 'sport_9': {'threshold': 21, 'quotient': 0.199},
 'sport_10': {'threshold': 30, 'quotient': 5.088}
}
``` 

* To `threshold` είναι η ελάχιστη επίδοση που πρέπει να έχει σε αυτό το διαγώνισμα για να περάσει. 
* Το `quotient` είναι ο συντελεστής τους αθλήματος. 

Στην ακαδημία δοκιμάστημαν 20 υποψήφιοι με τις εξής επιδόσεις:
```python
results = {
    "condidate_1": {
        "sport_1": 121,
        "sport_2": 98,
        "sport_3": 25,
        "sport_4": 20,
        "sport_5": 28,
        "sport_6": 29,
        "sport_7": 82,
        "sport_8": 80,
        "sport_9": 20,
        "sport_10": 122
    },
    "condidate_2": {
        "sport_1": 103,
        "sport_2": 95,
        "sport_3": 129,
        "sport_4": 68,
        "sport_5": 141,
        "sport_6": 96,
        "sport_7": 30,
        "sport_8": 90,
        "sport_9": 21,
        "sport_10": 100
    },
    "condidate_3": {
        "sport_1": 98,
        "sport_2": 144,
        "sport_3": 63,
        "sport_4": 139,
        "sport_5": 25,
        "sport_6": 81,
        "sport_7": 18,
        "sport_8": 118,
        "sport_9": 146,
        "sport_10": 148
    },
    "condidate_4": {
        "sport_1": 87,
        "sport_2": 81,
        "sport_3": 138,
        "sport_4": 114,
        "sport_5": 42,
        "sport_6": 95,
        "sport_7": 142,
        "sport_8": 140,
        "sport_9": 98,
        "sport_10": 52
    },
    "condidate_5": {
        "sport_1": 48,
        "sport_2": 100,
        "sport_3": 103,
        "sport_4": 66,
        "sport_5": 17,
        "sport_6": 14,
        "sport_7": 27,
        "sport_8": 148,
        "sport_9": 68,
        "sport_10": 19
    },
    "condidate_6": {
        "sport_1": 116,
        "sport_2": 54,
        "sport_3": 89,
        "sport_4": 12,
        "sport_5": 125,
        "sport_6": 148,
        "sport_7": 138,
        "sport_8": 66,
        "sport_9": 27,
        "sport_10": 35
    },
    "condidate_7": {
        "sport_1": 146,
        "sport_2": 49,
        "sport_3": 49,
        "sport_4": 148,
        "sport_5": 19,
        "sport_6": 119,
        "sport_7": 49,
        "sport_8": 14,
        "sport_9": 146,
        "sport_10": 79
    },
    "condidate_8": {
        "sport_1": 127,
        "sport_2": 28,
        "sport_3": 107,
        "sport_4": 55,
        "sport_5": 107,
        "sport_6": 135,
        "sport_7": 123,
        "sport_8": 75,
        "sport_9": 29,
        "sport_10": 137
    },
    "condidate_9": {
        "sport_1": 50,
        "sport_2": 40,
        "sport_3": 107,
        "sport_4": 131,
        "sport_5": 67,
        "sport_6": 74,
        "sport_7": 48,
        "sport_8": 80,
        "sport_9": 116,
        "sport_10": 41
    },
    "condidate_10": {
        "sport_1": 125,
        "sport_2": 98,
        "sport_3": 84,
        "sport_4": 129,
        "sport_5": 97,
        "sport_6": 39,
        "sport_7": 42,
        "sport_8": 68,
        "sport_9": 67,
        "sport_10": 52
    },
    "condidate_11": {
        "sport_1": 39,
        "sport_2": 37,
        "sport_3": 69,
        "sport_4": 81,
        "sport_5": 126,
        "sport_6": 39,
        "sport_7": 31,
        "sport_8": 67,
        "sport_9": 119,
        "sport_10": 45
    },
    "condidate_12": {
        "sport_1": 143,
        "sport_2": 12,
        "sport_3": 118,
        "sport_4": 114,
        "sport_5": 109,
        "sport_6": 108,
        "sport_7": 95,
        "sport_8": 82,
        "sport_9": 137,
        "sport_10": 64
    },
    "condidate_13": {
        "sport_1": 131,
        "sport_2": 85,
        "sport_3": 11,
        "sport_4": 146,
        "sport_5": 41,
        "sport_6": 97,
        "sport_7": 64,
        "sport_8": 145,
        "sport_9": 117,
        "sport_10": 110
    },
    "condidate_14": {
        "sport_1": 103,
        "sport_2": 67,
        "sport_3": 49,
        "sport_4": 100,
        "sport_5": 111,
        "sport_6": 73,
        "sport_7": 107,
        "sport_8": 94,
        "sport_9": 90,
        "sport_10": 73
    },
    "condidate_15": {
        "sport_1": 96,
        "sport_2": 17,
        "sport_3": 22,
        "sport_4": 83,
        "sport_5": 59,
        "sport_6": 99,
        "sport_7": 21,
        "sport_8": 18,
        "sport_9": 52,
        "sport_10": 87
    },
    "condidate_16": {
        "sport_1": 137,
        "sport_2": 105,
        "sport_3": 36,
        "sport_4": 115,
        "sport_5": 38,
        "sport_6": 102,
        "sport_7": 17,
        "sport_8": 56,
        "sport_9": 116,
        "sport_10": 64
    },
    "condidate_17": {
        "sport_1": 134,
        "sport_2": 14,
        "sport_3": 38,
        "sport_4": 50,
        "sport_5": 65,
        "sport_6": 51,
        "sport_7": 47,
        "sport_8": 128,
        "sport_9": 132,
        "sport_10": 85
    },
    "condidate_18": {
        "sport_1": 124,
        "sport_2": 117,
        "sport_3": 55,
        "sport_4": 37,
        "sport_5": 14,
        "sport_6": 79,
        "sport_7": 128,
        "sport_8": 66,
        "sport_9": 35,
        "sport_10": 19
    },
    "condidate_19": {
        "sport_1": 127,
        "sport_2": 54,
        "sport_3": 94,
        "sport_4": 26,
        "sport_5": 109,
        "sport_6": 49,
        "sport_7": 63,
        "sport_8": 123,
        "sport_9": 52,
        "sport_10": 127
    },
    "condidate_20": {
        "sport_1": 10,
        "sport_2": 57,
        "sport_3": 136,
        "sport_4": 37,
        "sport_5": 67,
        "sport_6": 113,
        "sport_7": 69,
        "sport_8": 87,
        "sport_9": 145,
        "sport_10": 52
    }
}
```

Τα κλειδιά του dictionary `results` είναι τα ονόματα των υποψηφίων και οι τιμές οι επιδόσεις τους σε κάθε ένα από τα αθλήματα.

Οι κανονισμοί είναι οι εξής:
* Αν ένας υποψήφιος σημειώσει απόδοση μικρότερη από το `threshold` σε έστω και 1 από τα αθλήματα τότε απορρίπτεται.
* Το τελικό σκορ του αθλητή είναι το άθροισμα του γινομένου της επίδοσής του σε κάθε άθλημα επί το `quotient` του αθλήματος αυτού. 

Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 2 dictionaries με την ίδια δομή όπως τα `sports` και `results` (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα επιστρέφει ένα string με το όνομα του αθλητή που σημείωση το μεγαλύτερο σκορ και δεν απορρίφθηκε σε κανένα αγώνισμα. 


## Σημαντικό για τις ασκήσεις 51-57

Για τις ασκήσεις 51-57, υποθέτουμε ότι έχει συμβεί κάτι συγκλονιστικό! Ένας εξωγήινος πολιτισμός ήρθε σε επαφή με εμάς και μέσω ενώς διαγαλαξιακού μηνύματος μας έστειλε ένα αρχείο κειμένου με το όνομα `alien.txt`το οποίο μπορείτε να κατεβάσετε από αυτό το link: https://www.dropbox.com/s/q8jtadm5ldkus26/alien.txt?dl=0

### Άσκηση 51

Γράψτε μία συνάρτηση η οποία θα παίρνει το όνομα ενός αρχείου, η συνάρτηση θα επιστρέφει τον μεγαλύτερο αριθμό που έχει το αρχείο ο οποίος εμπερικλύεται από παρενθέσεις, π.χ. ``(34543)``. Δίνεται η απάντηση:

```python
print (f('alien.txt')) # Τυπώνει: 94453 
```

### Άσκηση 52
Γράψτε μία συνάρτηση η οποία θα παίρνει το όνομα ενός αρχείου, η συνάρτηση θα επιστρέφει τον μεγαλύτερο αριθμό που έχει το αρχείο ο οποίος εμπερικλύεται από παρενθέσεις και επιτρέπεται να έχει ένα ή κανένα + μπροστά και οποιαδήποτε κενά μεταξύ των ψηφίων, π.χ. ``( +  3 45 4   3 )``. Δίνεται η απάντηση:

```python
print (f('alien.txt')) # Τυπώνει: 98777 
```

### Άσκηση 53
Γράψτε μία συνάρτηση η οποία θα παίρνει το όνομα ενός αρχείου, η συνάρτηση θα επιστρέφει το πλήθος από γραμμές οι οποίες ξεκινάνε με τον χαρακτήρα `^` και τελειώνουν με τον χαρακτήρα `$`. Δίνεται η απάντηση:

```python
print (f('alien.txt')) # Τυπώνει: 12  
```

### Άσκηση 54
Το αρχείο `alien.txt` περιέχει μερικές γραμμές οι οποίες να περιέχουν 2 άρτιους (ζυγούς) αριθμούς τον έναν δίπλα από τον άλλο. Δηλαδή πριν τον 1ο να υπάρχει whitespace, ανάμεσά τους να υπάρχει whitespace και μετά τον 2ο να υπάρχει whitespace. Ποιο είναι το μεγαλύτερο άθροισμα από όλα αυτά τα ζευγάρια; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο και θα επιστρέφει την απάντηση. Δίνεται η απάντηση:

```python
print (f()) # Τυπώνει: 104  
```

### Άσκηση 55 
Το αρχείο `alien.txt` περιέχει μόνο μία λέξη (δηλαδή ακολουθία χαρακτήρων που δεν περιέχει whitespace) η οποία να αποτελείται από 4 επαναλήψεις ενός χαρακτήρα που δεν είναι αριθμός και ενός χαρακτήρα που είναι αριθμός. Ποια είναι αυτή η λέξη; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο και θα επιστρέφει την απάντηση. Δίνεται η απάντηση:

```python
print (f()) # Τυπώνει: L0E4L9v7  
```

### Άσκηση 56 
Το αρχείο `alien.txt` περιέχει μόνο έναν αριθμό που θα μπορούσε να είναι αριθμός κινητού τηλεφώνου στην Ελλάδα (δηλαδή 69 ακολουθούμενο από 8 αριθμούς). Ποιος είναι αυτός ο αριθμός; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο και θα επιστρέφει ένα string με την απάντηση. Δίνεται η απάντηση:

```python
print (f()) # Τυπώνει: 6919876565  
```

### Άσκηση 57 
Μέσα στο αρχείο υπάρχουν πολλές ακολουθίες από χαρακτήρες που θα μπορούσαν να είναι νόμιμες εκφράσεις στη python όπου αναθέτουμε έναν ακέραιο σε μία μεταβλητή. Για παράδειγμα: `kM3HK=7`. Ποιο είναι το άθροισμα όλων των ακεραίων σε όλες τις εκφράσεις αυτού του τύπου που βρίσκονται στο αρχείο; Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο και θα επιστρέφει ένα ακέραιο με την απάντηση. Μερικές σημειώσεις:

* Το όνομα μίας μεταβλητής στη python δεν μπορεί να ξεκινάει με αριθμό.
* Όλα τα υπόλοιπα γράμματα μπορεί να είναι "\w" 
* Θα πρέπει να πιάνετε περιπτώσεις όπου υπάρχει white space πριν και μετά το `=`. Για παράδειγμα `aa =33`, `bb=  66`, `cc  =   99`.
* Πριν από την έκφραση θα πρέπει να υπάρχει ή white space ή η αρχή της γραμμής. π.χ. αυτό: `>aa=33 ` δεν θεωρείται python έκφραση. Αυτή όμως θεωρείται: ` aa=33 `
* Μετά από την έκφραση θα πρέπει να υπάρχει ή white space ή το τέλος της γραμμής. π.χ. αυτό: ` aa=33<` δεν θεωρείται python έκφραση. Αυτή όμως θεωρείται: ` aa=33 `

Δίνεται η απάντηση:
```python
print (f()) # Τυπώνει: 2722
```

### Άσκηση 58 

Αν τρέξετε τη συνάρτηση `ask_58_create_file()` θα δημιουργήσει ένα αρχείο με όνομα `ask_58_1.txt` με τα εξής περιεχόμενα:

```text
A=5,6,7,8,9|B=8,6,7|C=5,4,5,3,2
A=1,6,7,6,5|B=6,8,9|C=7,8,8,8,8
A=7,6,9,2,1|B=1,2,3|C=7,8,1,1,2
```

```python
def ask_38_create_file():


    with open('ask_58_1.txt', 'w') as f:

        f.write(f'A=5,6,7,8,9|B=8,6,7|C=5,4,5,3,2\n')
        f.write(f'A=1,6,7,6,5|B=6,8,9|C=7,8,8,8,8\n')
        f.write(f'A=7,6,9,2,1|B=1,2,3|C=7,8,1,1,2\n')
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα διαβάζει ένα αρχείο με το όνομα της παραμέτρου το οποίο θα έχει την ίδια δομή όπως το `ask_38_1.txt` και θα σώζει τη πληροφορία που έχει σε ένα αλλο αρχείο με το όνομα `ask_58_2.txt` με την εξής μορφή:

```text
A=(5,1,7), (6,6,6), (7,7,9), (8,6,2), (9,5,1)
B=(8,6,1), (6,8,2), (7,9,3)
C=(5,7,7), (4,8,8), (5,8,1), (3,8,1), (2,8,2)
```

Δηλαδή θα πρέπει:
```python
ask_38_create_file()
f('ask_38_1.txt')
with open('ask_38_2.txt') as f:
    for l in f:
        print (l.strip())
# Τυπώνει:
A=(5,1,7), (6,6,6), (7,7,9), (8,6,2), (9,5,1)
B=(8,6,1), (6,8,2), (7,9,3)
C=(5,7,7), (4,8,8), (5,8,1), (3,8,1), (2,8,2)
```

Σημειώσεις:
* Εννοείται ότι το αρχείο `ask_58_1.txt` μπορεί να έχει περισσότερες από 3 γραμμές και περισσότερα από 3 γράμματα (όχι μόνο A,B,C).
* Το όνομα της μεταβλητής θεωρούμε ότι ξεκινάει μόνο με γράμματα.

### Άσκηση 59 
(Το αντίθετο με την άσκηση 58)

Αν τρέξετε τη συνάρτηση `ask_59_create_file()` θα δημιουργήσει ένα αρχείο με όνομα `ask_59_1.txt` με τα εξής περιεχόμενα:

```text
A=(5,1,7), (6,6,6), (7,7,9), (8,6,2), (9,5,1)
B=(8,6,1), (6,8,2), (7,9,3)
C=(5,7,7), (4,8,8), (5,8,1), (3,8,1), (2,8,2)
```

```python
def ask_39_create_file():


    with open('ask_59_1.txt', 'w') as f:

        f.write(f'A=(5,1,7), (6,6,6), (7,7,9), (8,6,2), (9,5,1)\n')
        f.write(f'B=(8,6,1), (6,8,2), (7,9,3)\n')
        f.write(f'C=(5,7,7), (4,8,8), (5,8,1), (3,8,1), (2,8,2)\n')
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα string (δεν χρειάζεται να το ελέγξετε αυτό). Η συνάρτηση θα διαβάζει ένα αρχείο με το όνομα της παραμέτρου το οποίο θα έχει την ίδια δομή όπως το `ask_39_1.txt` και θα σώζει τη πληροφορία που έχει σε ένα αλλο αρχείο με το όνομα `ask_59_2.txt` με την εξής μορφή:

```text
A=5,6,7,8,9|B=8,6,7|C=5,4,5,3,2
A=1,6,7,6,5|B=6,8,9|C=7,8,8,8,8
A=7,6,9,2,1|B=1,2,3|C=7,8,1,1,2
```

Δηλαδή θα πρέπει:
```python
ask_39_create_file()
f('ask_39_1.txt')
with open('ask_39_2.txt') as f:
    for l in f:
        print (l.strip())
# Τυπώνει:
A=5,6,7,8,9|B=8,6,7|C=5,4,5,3,2
A=1,6,7,6,5|B=6,8,9|C=7,8,8,8,8
A=7,6,9,2,1|B=1,2,3|C=7,8,1,1,2
```

Σημείωση: Εννοείται ότι το αρχείο `ask_59_1.txt` μπορεί να έχει περισσότερες από 3 γραμμές και περισσότερα από 3 γράμματα (όχι μόνο A,B,C).

### Άσκηση 60 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt` το οποίο περιέχει όλες τις ελληνικές λέξεις. Οι λέξεις είναι κανονικοποιημένες δηλαδή:
* Όλα είναι μικρά
* Οι τόνοι και τα διαλυτικά έχουν αντικατασταθεί με τα αντίστοιχα γράμματά τους (π.χ ά --> α)
* Το τελικό `ς` έχει αντικατασταθεί με το `σ`.

Στο θέμα μας τώρα.. Στη πρώτη δημοτικού, οι λέξεις που ξεκινάνε να γράφουν και να διαβάζουν τα παιδιά αποτελούνται κυρίως από συλλαβές που έχουν 2 γράμματα. Για παράδειγμα: `πανί`, `τόπι`, `μήλο`, `ποδήλατο`, `κασετίνα`. Φτιάξτε λοιπόν μία συνάρτηση η οποία θα παίρνει σαν παράμετρο το όνομα ενός αρχείου με την ίδια δομή όπως το `words_greek_normalized.txt`. Η συνάρτηση θα σώζει στο αρχείο με το όνομα `easy_words.txt` όλες τις ελληνικές λέξεις οι οποίες αποτελούνται από συλλαβές που έχουν 2 γράμματα. Το πρώτο γράμμα πρέπει να είναι σύμφωνο (`βγδζθκλμνξπρστφχψ`) και το δεύτερο φωνήεν (`αεηιουω`). Κάθε γραμμή στο αρχείο θα πρέπει να έχει και μία λέξη. Η συνάρτηση δεν θα επιστρέφει τίποτα. Θα πρέπει δηλαδή:

```python
f('words_greek_normalized.txt')
with open('easy_words.txt') as f:
    c = 0
    for l in f:
        c += 1
    print (f'Σύνολο: {c}')
Σύνολο: 15338
```

* Σημείωση: Σε μία παλαιότερη έκδοση αυτής της άσκησης είχα αναφέρει λανθασμένα ότι το πλήθος των σωστών λέξεων είναι 10547

### Άσκηση 61 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt`

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα μικρά γράμματα της ελληνικής αλφαβήτας. Οι τιμές θα είναι το πλήθος από λέξεις οι οποίες ξεκινάνε με αυτό το γράμμα σύμφωνα με το αρχείο `words_greek_normalized.txt`. 


Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε [Counter](https://docs.python.org/3/library/collections.html#collections.Counter). 

### Άσκηση 62 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt`

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα μικρά γράμματα της ελληνικής αλφαβήτας. Οι τιμές θα είναι το πλήθος από λέξεις οι οποίες ξεκινάνε με αυτό το γράμμα σύμφωνα με το αρχείο `words_greek_normalized.txt`. 


Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict).

### Άσκηση 63 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt`

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα μικρά γράμματα της ελληνικής αλφαβήτας. Οι τιμές θα είναι το πλήθος από λέξεις οι οποίες ξεκινάνε με αυτό το γράμμα σύμφωνα με το αρχείο `words_greek_normalized.txt`. 


Σημείωση: Είναι υποχρεωτικό να χρησιμοποιήσετε [itertools.groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby).
Hint: Για να δουλέψει σωστά η groupby πρέπει η λίστα να είναι ταξονομημένη. 

### Άσκηση 64 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt`

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα dictionary όπου τα κλειδιά θα είναι όλα τα μικρά γράμματα της ελληνικής αλφαβήτας. Οι τιμές θα είναι το πλήθος από λέξεις οι οποίες ξεκινάνε με αυτό το γράμμα σύμφωνα με το αρχείο `words_greek_normalized.txt`. 


Σημείωση: Μη χρησιμοποιήσετε [Counter](https://docs.python.org/3/library/collections.html#collections.Counter), [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict) ή [itertools.groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby). 

### Άσκηση 65
Έστω `n` ένας τυχαίος αριθμός από το 1 μέχρι και το 1000. Ποια είναι η πιθανότητα να μην υπάρχει κανένας πρώτος αριθμός από το n μέχρι και το n+9;

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα φτιάχνει 10.000 τυχαίους n και θα επιστρέφει το ποσοστό αυτών που έχουν την παραπάνω ιδιότητα. 

### Άσκηση 66
Αν υποθέσουμε ότι τα τρία σημεία ενός τριγώνου Α,Β,Γ βρίσκονται στα σημεία: (Χ<sub>A</sub>, Υ<sub>A</sub>), (Χ<sub>B</sub>, Υ<sub>B</sub>) και (Χ<sub>Γ</sub>, Υ<sub>Γ</sub>) τότε το εμβαδόν του είναι ([πηγή](https://en.wikipedia.org/wiki/Triangle#Area)):

![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/16c43b4e96346a8a1b86097618fdd30c4e4a9b32)

Έστω ότι τα παρακάτω σύνολα σημείων:
```python
S_1 = [
 (-44.01, -37.17),
 (-40.15, 22.65),
 (35.69, -25.12),
 (-2.2, 36.35),
 (-37.96, 12.24),
 (10.65, 29.59),
 (-22.78, 48.35),
 (-42.13, 33.88),
 (-49.78, -42.15),
 (-11.16, -4.25)
]

S_2 = [
 (-15.1, -44.87),
 (5.62, -44.22),
 (-8.6, -38.89),
 (2.22, 41.26),
 (-43.73, 0.64),
 (24.69, -4.72),
 (6.94, 39.15),
 (-0.62, 24.1),
 (45.6, -11.61),
 (-27.31, -11.51),
]

S_3 = [
 (25.67, -47.55),
 (-7.55, 44.2),
 (-32.86, 0.58),
 (-39.38, 11.36),
 (-20.08, 25.73),
 (-5.55, 43.33),
 (37.67, 41.97),
 (-21.57, 26.77),
 (8.84, 12.54),
 (24.12, 3.97),
]
```

Από όλα τα τρίγωνα Α,Β,Γ τα οποία μπορούν να σχηματιστούν αν: Το σημείο Α ανήκει στο `S_1`, το σημείο B ανήκει στο `S_2` και το σημείο Γ ανήκει στο `S_3` ποιο έχει το μικρότερο εμβαδόν;

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 3 λίστες με την ίδια δομή όπως τις `S_1`, `S_2` και `S_3`. Η συνάρτηση πρέπει να επιστρέφει τρεις αριθμούς οι οποίοι είναι οι δίκτες (indexes) των σημείων στις λίστες `S_1`, `S_2` και `S_3` που σχηματίζουν το μικρότερο εμβαδόν. Δηλαδή κάθε ένας από τους 3 αριθμούς θα πρέπει να ανήκει στο διάστημα [0, 9]. 

Δηλαδή θα πρέπει:
```python
print (f(S_1, S_2, S_3)) #  Τυπώνει ένα tuple με 3 αριθμούς
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τη [product](https://docs.python.org/3/library/itertools.html#itertools.product)

### Άσκηση 67

Έστω η παρακάτω λίστα σημείων:

```python
S = [
 (-15.01, 6.31),
 (3.48, 18.51),
 (-1.93, -4.41),
 (-2.54, -36.13),
 (-10.62, 35.12),
 (-15.29, 31.85),
 (15.02, -1.13),
 (47.69, -41.41),
 (48.33, 39.15),
 (8.99, 10.17),
 (19.13, 29.09),
 (22.71, 49.55),
 (1.81, -32.67),
 (5.05, -37.53),
 (-44.16, -34.83),
 (-16.93, 8.36),
 (1.39, -15.56),
 (-43.82, 11.6),
 (-6.97, 7.53),
 (30.39, -21.45),
 (45.29, 8.12),
 (-9.02, -48.07),
 (-7.44, 43.51),
 (3.74, 25.33),
 (26.97, 12.57),
 (32.59, -43.21),
 (37.79, -2.49),
 (-8.71, 32.03),
 (-42.4, 17.28),
 (-36.22, 36.38),
 (-24.13, -0.94),
 (30.56, 33.76),
 (-4.91, 41.0),
 (5.73, -42.27),
 (42.46, -38.52),
 (-28.19, 25.26),
 (42.07, -5.42),
 (43.16, -33.38),
 (47.76, -41.65),
 (-25.64, -13.43),
 (-33.28, -49.91),
 (-21.35, -24.52),
 (24.87, -44.45),
 (-21.44, -40.46),
 (29.08, 6.97),
 (-19.77, 19.68),
 (14.17, -30.92),
 (-36.93, -28.72),
 (-41.14, -14.3),
 (21.14, -35.95),
 (-17.48, 22.8),
 (35.71, 49.83),
 (-15.76, -6.71),
 (20.43, -46.28),
 (-46.63, -34.48),
 (40.85, 16.15),
 (-17.89, 38.35),
 (-44.59, 29.8),
 (-5.86, -29.39),
 (-40.21, 43.27),
 (-30.18, 11.52),
 (33.91, 2.83),
 (39.39, -22.01),
 (-15.58, 12.68),
 (11.95, -49.36),
 (-17.09, 41.52),
 (-41.8, -14.44),
 (22.95, -10.94),
 (-16.21, -40.27),
 (43.91, 7.18),
 (-1.12, -25.06),
 (-17.88, -35.94),
 (18.94, -45.69),
 (-47.16, 20.15),
 (-26.55, 0.88),
 (-18.03, 18.6),
 (38.33, 10.81),
 (-23.4, -14.08),
 (-44.97, 6.51),
 (10.98, -21.74),
 (9.54, 20.15),
 (-37.17, 18.6),
 (9.23, 31.8),
 (-47.1, 2.04),
 (-16.45, -1.91),
 (25.31, -12.45),
 (-45.12, -5.21),
 (-47.99, -12.63),
 (36.58, -19.4),
 (34.72, 9.76),
 (-44.51, -11.83),
 (45.78, 13.84),
 (15.19, -2.97),
 (39.44, 49.41),
 (-9.23, 26.34),
 (13.55, 18.85),
 (-11.43, 14.66),
 (-32.99, 33.92),
 (-22.91, -16.26),
 (28.35, -3.41)]
```

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο 1 λίστα με την ίδια δομή όπως τη `S`. Η συνάρτηση πρέπει να επιστρέφει τρεις αριθμούς οι οποίοι είναι οι δίκτες (indexes) των τριών διαφορετικών σημείων στη λίστα `S`, που σχηματίζουν το μικρότερο εμβαδόν. Δηλαδή κάθε ένας από τους 3 αριθμούς θα πρέπει να ανήκει στο διάστημα [0, len(S)-1]. Δηλαδή θα πρέπει:

```python
print f(S) # Τυπώνει ένα tuple με 3 αριθμούς.
```

Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τη [combinations](https://docs.python.org/3/library/itertools.html#itertools.combinations)

### Άσκηση 68 
Φτιάξτε ένα αρχείο με το όνομα `ask_68.py`. Το αρχεί θα πρέπει να είναι τέτοιο ώστε:
* Αν το τρέχω από το command line και κάνω:
```bash
python ask_68.py --parameter_1 25 --parameter_2 20 50 60 70 
``` 
Τότε θα τυπώσει:
```text
20
```

Τυπώνει δηλαδή τον αριθμό που υπάρχει στη λίστα των αριθμών στο `parameter_2` ο οποίος έχει τη μικρότερη απόλυτη διαφορά από τον αριθμό του `--parameter_1`

* Από κάποιο άλλο πρόγραμμα python ή από το jupyter θα μπορώ να κάνω:
```python
from ask_68 import closer

print (closer(25, [20, 50, 60, 60])) # Τυπώνει 20 
```

Βάτε το σχόλιο `# άσκηση 68` στη κορυφή της υλοποίσής σας. Μπορείτε να βάλετε την υλοποίηση σε κάποιο κελί κώδικα στο jupyter ή να το στείλετε σε ξεχωριστό αρχείο. 

### Άσκηση 69 
Το [λόττο](https://www.opap.gr/pws-paizetai-to-lotto) παίζεται επιλέγοντας τυχαία 6 από 49 αριθμούς. Πόσες διαφρετικές 6άδες υπάρχουν οι οποίες:
* Να έχουν τουλάχιστον 1 άρτιο αριθμό
* Να μην έχουν κανέναν αριθμό που να τελειώνει σε '3' (δλδ 3, 13, 23, 33, 43).

Φτιάξτε μία συνάρτηση η οποία να μην παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει την απάντηση στο παραπάνω ερώτημα. 

### Άσκηση 70 
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt`

Χρησιμοποιώντας αυτό το αρχείο, βρείτε, ποιος είναι ο συνδυασμός από 4 διαφορετικά γράμματα τις ελληνικής αλφαβήτα με τα οποία μπορούμε να σχηματίσουμε τις περισσότερες ελληνικές λέξεις.

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα επιστρέφει ένα tuple με τα 4 γράμματα τα οποία απαντάνε στο παραπάνω ερώτημα.


## Ασκήσεις 71-80
* **Σημείωση 1: Στις ασκήσεις 71-80 καλείστε να υλοποιήσετε τον αλγόριθμο clustering [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN). Ένα πολύ καλό video το οποίο εξηγεί πως δουλεύει ο αλγόριθμος βρίσκεται [εδώ](https://www.youtube.com/watch?v=RDZUdRSDOok)** 
* **Σημείωση 2: Με εξαίρεση τις 79 και 80, προσπαθήστε να τις κάνετε χωρίς κανένα for (ούτε comprehension). Αν βάλετε for δεν θα μειωθεί ο βαθμός. Απλά θεωρώ ότι οι τύψεις που θα σας φέρουν τα λυπημένα κουνελάκια, θα έχουν μεγαλύτερη συνέπεια από την απειλή της μείωσης της βαθμολογίας!**

### Άσκηση 71 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο έναν δι-διάστατο numpy πίνακα Ν γραμμών. Η συνάρτηση πρέπει να επιστρέφει έναν Ν x N numpy πίνακα όπου το στοιχεία i,j του πίνακα θα περιέχει την ευκλείδεια απόσταση του σημείου i από το σημείο j. Για παράδειγμα θα πρέπει:

```python
ar = np.array([[1,2], [-1,4], [0,5]])

print (f(ar))
# Τυπώνει:
[[0.         2.82842712 3.16227766]
 [2.82842712 0.         1.41421356]
 [3.16227766 1.41421356 0.        ]]

``` 

### Άσκηση 72
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παραμέτρους:
* Ένας πίνακας Nx2, `C`) 
* Ένας ακέραιος `minPTS` 
* Ένας δεκαδικός αριθμός: `eps`


Η συνάτηση θα επιστρέφει έναν μονοδιάστατο πίνακα ο οποίος θα περιέχει τους δείκτες των γραμμών (line indexes) του πίνακα `C`, οι οποίες αντιστοιχούν στα σημεία για τα οποία υπάρχουν περισσότερα από `minPTS` άλλα σημεία με τα οποία να απέχουν μικρότερο από απόσταση `eps`. 

Σημείωση: Προφανώς θα πρέπει να χρησιμοποιήσετε τη συνάρτηση της άσκησης 71 για να υπολογίσετε όλες τις δυνατές αποστάσεις μεταξύ όλων των σημείων.


Για παράδειγμα θα πρέπει:
```python
C = np.array([[0.3, 0.5],
       [0.9, 0.2],
       [0.8, 0.2],
       [0.5, 0.3],
       [0.6, 0.5],
       [0.3, 0.4],
       [0.3, 0. ],
       [0.3, 0.2],
       [0.2, 0.1],
       [0. , 0.5]])

print (f(C, minPTS=3, eps = 0.3)) # Τυπώνει 0, 3, 7 
```

Εξήγηση:
```
Η 0-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 5 γραμμές (εκτός από τον εαυτό της)
Η 1-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 1 γραμμές (εκτός από τον εαυτό της)
Η 2-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 1 γραμμές (εκτός από τον εαυτό της)
Η 3-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 4 γραμμές (εκτός από τον εαυτό της)
Η 4-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 2 γραμμές (εκτός από τον εαυτό της)
Η 5-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 3 γραμμές (εκτός από τον εαυτό της)
Η 6-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 2 γραμμές (εκτός από τον εαυτό της)
Η 7-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 5 γραμμές (εκτός από τον εαυτό της)
Η 8-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 2 γραμμές (εκτός από τον εαυτό της)
Η 9-η γραμμή έχει απόσταση μικρότερη από 0.3 με άλλες 1 γραμμές (εκτός από τον εαυτό της)


Από όλες τις γραμμές μόνο η 0, η 3 και η 7 έχει απόσταση μικρότερη από 0.3 με περισσότερες από 3 γραμμές. 
```


### Άσκηση 73
Φτιάξτε μία συνάρτηση η οποία θα παίρει σαν παράμετρο:
* Έναν πίνακα C με διαστάστάσεις N x 2. 
* Έναν ακέραιο `minPTS` 
* Ένα δεκαδικός αριθμό: `eps`

Η συνάρτηση θα πρέπει:
1. Να υπολογίζει όλες τις δυνατές αποστάσεις μεταξύ όλων των σημείων του C (άσκηση 71)
2. Να υπολογίζει τους δείκτες των γραμμώνν (line indexes) όπως περιγράφηκε στην άσκηση 72 και να τα αποθηκεύει σε μία μεταβλητή με το όνομα `CP`.
3. Να υπολογίζει τους δείκτες των γραμμώνν (line indexes) οι οποίες υπάρχουν στον C αλλά δεν υπάρχουνν στον `CP` και να το αποθηκεύει σε μία μεταβλητή με το όνομα `non_CP`.

Επιστρέφει τα `CP` και `non_CP`

Θα πρέπει δηλαδή:

```python
C = np.array([[0.3, 0.5],
       [0.9, 0.2],
       [0.8, 0.2],
       [0.5, 0.3],
       [0.6, 0.5],
       [0.3, 0.4],
       [0.3, 0. ],
       [0.3, 0.2],
       [0.2, 0.1],
       [0. , 0.5]])


CP, non_CP = ask_73(C, 3, 0.3)
print (CP) # Τυπώνει [0 3 7]
print (non_CP) # Τυπώνει [1 2 4 5 6 8 9]

```

### Άσκηση 74
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο:
* έναν πίνακα N x Ν ο οποίος περιέχει όλες τις δυνατές αποστάσεις ενός πίνακα διαστάσεων Ν x 2 (σαν αυτό που επιστρέφει η άσκηση 71)
* Έναν πίνακα με δείκτες γραμμών με το όνομα `CP`
* Έναν ακέραιο `minPTS` 
* Ένα δεκαδικός αριθμό: `eps`
* Έναν αριθμό ο οποίος θα είναι από το 0 μέχρι και το Ν-1 (έστω `r`)

Η συνάρτηση θα πρέπει να:
1. Αρχικοποιεί ένα άδειο σύνολο S (μπορεί να είναι και numpy array) 
2. Υπολογίζει όλα τα στοιχεία τα οποία (1) ανήκουν στο `CP` και (2) απέχουν από το `r`-οστό σημείο του Ν, απόσταση μικρότερη από `eps` <!--υπάρχουν τουλάχιστον `minPTS` στοιχεία τα οποία ανήκουν στο `CP` και απέχουν από το `r`  απόσταση μικρότερη από `eps`. !-->
   * Επεξήγηση: Ας υποθέσουμε ότι ο CP περιέχει τα σημεία: [1,5,8,9] και ότι το r=7. Τότε θα πρέπει να υπολογίσει όλα τα σημεία του CP τα οποία απέχουν απόσταση από το 7ο σημείο του Ν απόσταση μικρότερη από `eps`. Θυμόμαστε ότι ο CP είναι ένας πίνακας με δείκτες γραμμών. Άρα: 
      * υπολογίζει την απόσταση του 1ου σημείου του Ν με το 7ο σημείο του Ν και αν η απόσταση είναι μικρότερη από `eps` τότε προσθέτει το `1` στο S.
      * υπολογίζει την απόσταση του 5ου σημείου του Ν με το 7ο σημείο του Ν και αν η απόσταση είναι μικρότερη από `eps` τότε προσθέτει το `5` στο S.
      * υπολογίζει την απόσταση του 8ου σημείου του Ν με το 7ο σημείο του Ν και αν η απόσταση είναι μικρότερη από `eps` τότε προσθέτει το `8` στο S.
      * υπολογίζει την απόσταση του 9ου σημείου του Ν με το 7ο σημείο του Ν και αν η απόσταση είναι μικρότερη από `eps` τότε προσθέτει το `9` στο S.

3. Πρoσθέτει τα στοιχεία που βρήκε από το βήμα 2 στο σύνολο S.
4. Παίρνει έναν τυχαίο αριθμό απο το 0 έως το Ν-1 το οποίο να αντιστοιχεί σε ένα στοιχείο του S το οποίο όμως να μην το έχει ξαναπάρει, και το θέτει σαν `r`. Δηλαδή η μεταβλητή `r` δεν θα πρέπει να παίρνει δύο φορές την ίδια τιμή. 
5. Επαναλαμβάνει τα βήματα 2,3,4 μέχρι να μην υπάρχει κάποιο στοιχείο του συνόλου S το οποίο να μην το έχει πάρει. 

Η συνάρτηση θα επιστρέφει το σύνολο S. 

### Άσκηση 75
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο:
* Ένα σύνολο από σημεία `S`
* Ένα σύνολο από σημεία `non_CP`
* Έναν αριθμός `eps`.
* Έναν πίνακα αποστάσεων NxN (έστω `D`)

H συνάρτηση θα πρέπει να βρίσκει όλα τα σημεία τα οποία (1) ανήκουν στο `non_CP` και (2) υπάρχει τουλάχιστον ένα σημείο το οποίο να ανήκει στο `S` και νά έχει απόσταση μικρότερη από `eps`. Η συνάρτηση θα επιστρέφει το σύνολο των σημείων αυτών.

### Άσκηση 76
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο:
* Έναν πίνακα Ν Χ 2, έστω `C`.
* Έναν ακέραιο `minPTS` 
* Ένα δεκαδικός αριθμό: `eps`

Η συνάρτηση θα πρέπει:
1. Να υπολογίζει όλες τις δυνατές αποστάσεις μεταξύ των σημείων του C (άσκηση 71).
2. Να υπολογίζει τα `CP` και `non` (άσκηση 73)
3. Θέτει στη μεταβλητή με το όνομα `cluster_name` τη τιμή: 1. 
4. Θέτει στη μεταβλητή `clusters` έναν άδειο dictionary (`clusters = {}`)
5. Παίρνει ένα τυχαίο σημείο από το `CP`, έστω `r`.
6. Υπολογίζει το σύνολο που επιστρέφει η συνάρτηση της άσκησης 74, έστω `S`.
7. Υπολογίζει το σύνολο που επιστρέφει η συνάρτηση της άσκησης 75, έστω `Τ`.
8. Τα στοιχεία που υπάρχουν στο `S` και στο `T` θα τα αποθηκεύει στο dictionary `clusters` όπου σαν κλειδί θα έχει το `cluster_name` και σαν τιμή θα έχει ένα dictionary όπως αυτό: `{"S": S, "T", T}` 
9. Θα παίρνει ένα τυχαίο σημείο το οποίο να ανήκει στo CP και να μην ανήκει σε κανένα από όλα τα σετ που υπάρχουν στα dictionaries των τιμών του `clusters`. Θα θέτει το σημείο αυτό στη μεταβλητή `r`. Αν δεν υπάρχει τέτοιο σημείο, τότε θα **επιστρέφει** το dictionary `clusters`.
10. Αυξάνει το `cluster_name` κατά 1.
11. Πηγαίνει στο βήμα 6.



### Άσκηση 77
Δίνεται η παρακάτω συνάρτηση:
```python
import numpy as np
import matplotlib.pyplot as plt 

def create_blob():
    N = 1000
    mean_1 = np.array([2,3])
    cov_1 = np.array([[2.0, 0.3], [0.3, 0.5]])
    A = np.random.multivariate_normal(mean_1, cov_1, N)
    return A


data = create_blob()


```

Αυτός ο κώδικας δημιουργεί 1000 τυχαία σημεία στον 2-διάστατο χώρο. 

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση:
1. Φτιάχνει έναν πίνακα `C` από τη συνάρτηση `create_blob`
2. Θα καλέι τη συνάρτηση της άσκησης 76 με `minPTS = 3` και `eps = 0.3`. Το αποτέλεσμα που επιστρέφει θα το αποθηκεύει σε μία μεταβλητή με το όνομα clusters. 
3. Θα βρίσκει τον cluster με το μεγαλύτερο πλήθος στοιχείων.
4. Θα κάνει plot τα στοιχεία που βρίσκονται στο σύνολο `S` αυτού του cluster με χρώμα πράσινο
5. Θα κάνει plot τα στοιχεία που βρίσκονται στο σύνολο `T` αυτού του cluster με χρώμα κόκκινο
6. Θα κάνει plot τα στοιχεία που βρίσκονται `C` αλλά δεν ανήκουν ούτε στο `S` αλλά ούτε στο `T` με χρώμα μαύρο

Δίνεται το plot που βγήκε σε εμένα:

![img](https://i.imgur.com/CFamjVb.png)


### Άσκηση 78
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία παράμετρο με το όνομα K η οποία θα είναι ένας αριθμός και μία παράμετρο to_plot η οποία θα είναι λογική τιμή (δεν χρειάζεται να ελέγξετα αυτά). Η συνάρτηση θα πρέπει:

1. Φτιάχνει έναν πίνακα Α ο οποίος είναι ακριβώς αυτός που επιστρέφει η `create_blob` που φαίνεται στην εκφώνηση της άσκησης 77.
2. Φτιάχνει έναν πίνακα B ο οποίος έχει τα ίδια στοιχεία με τον Α αλλά είναι μετατοπισμένος κατά -Κ στον χ άξονα 
3. Φτιάχνει έναν πίνακα C ο οποίος έχει τα ίδια στοιχεία με τον Α αλλά είναι μετατοπισμένος κατά -Κ στον χ άξονα και κατά -K στον y άξονα. 
4. Φτιάχνει έναν πίνακα D ο οποίος έχει τα ίδια στοιχεία με τον Α αλλά είναι μετατοπισμένος κατά -Κ στον y άξονα. 
5. Αν η `to_plot` είναι `True` θα κάνει plot όλα τα σημεία με μαύρες κουκίδες. 

Θα πρέπει δηλαδή:
```python
f(10, to_plot=True)
```

Παράγει το παρακάτω plot:

![img](https://i.imgur.com/6v6ZnkU.png)


Η συνάρτηση θα πρέπει να συνενώνει κάθετα ([vstack](https://numpy.org/doc/stable/reference/generated/numpy.vstack.html)) επιστρέφει τον πίνακα με τα σημεία που έφτιαξε (δηλαδή 4000 σημεία στο σύνολο)

### Άσκηση 79 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν όρισμα έναν αριθμό `Κ` και έναν άλλο αριθμό `minPTS`. Η συνάρτηση θα πρέπει:

1. Παράγει τον πίνακα που επιστρέφει η συνάρτηση της άσκησης 78 με τη παράμετρο `Κ` (θέστε`to_plot=False`) και τον αποθηκεύει στη μεταβλητή `C`. 
2. Τρέχει τη συνάρτηση της άσκησης 76 για τον C, με `minPTS = minPTS` (η παράμετρος δηλαδή), `eps = 0.3` και αποθηκεύει το αποτέλεσμα στη μεταβλητή `clusters`.
3. Κάνει plot όλα τα σημεία που βρίσκονται στα sets με το όνομα `S` των κλειδιών των values του `clusters` με πράσινο χρώμα.
4. Κάνει plot όλα τα σημεία που βρίσκονται στα sets με το όνομα `T` των κλειδιών των values του `clusters` με κόκκινο χρώμα.
5. Κάνει plot όλα τα σημεία του C που δεν βρίσκονται στα sets με το όνομα `T` και `S` των κλειδιών των values του `clusters` με μαύρο χρώμα.

Δίνεται το plot το οποίο έγινε σε εμένα:

```python
ask_79(K=10, minPTS=3)
```

![img](https://i.imgur.com/29Hq7GY.png)

### Άσκηση 80
Φιάξτε μία συνάρτηση η οποια δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα φτιάχνει μία γραφική παράσταση με ένα 10 x 10 grid με όλες τις γραφικές παραστάσεις της άσκησης 79 για `K in range(1,11)` και `minPTS in range(1,11)`. 

Δίνεται το αριστούργημα που βγήκε σε μένα:

![img](https://i.imgur.com/oaZBi9p.png)


### Άσκηση 81
Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα φτιάχνει μία γραφική παράσταση σε matplotlib η οποία θα μοιάζει με το γράμμα "Ε". Για παράδειγμα:

![img](https://i.imgur.com/7yN0PEh.png)

### Άσκηση 82 
(πρόκειται για οπτικοποίηση του αποτελέσματος της άσκησης 8)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει 3 ορίσματα Α,Β,d. Τα Α και Β θα είναι tuples με 2 αριθμούς το κάθε ένα και το d θα είναι ένας αριθμός (δεν χρειάζεται να το ελέγξετε αυτό). 
* Αν τα 2 σημεία στον 2-διάστατο χώρο που ορίζονται από τις συντεταγμένες που υπάρχουν στα tuples Α και Β ταυτίζονται, τότε θα πρέπει να επιστρέφει τo string "λάθος".
* Διαφορετικά υπολογίζει 2 tuples, το κάθε ένα με 2 αριθμούς. Το κάθε tuple εκπροσωπεί τα 2 σημεία Κ,Λ τα οποία ανήκουν στη μεσοκάθετο της Α,Β και απέχουν από το μέσο της Α,Β απόσταση d.

Η συνάρτηση φτιάχνει μία γραφική παράσταση με:
* Το ευθύγραμμο τμήμα ΑΒ σε χρώμα μαύρο
* Το ευθύγραμμο τμήμα ΚΛ σε μπλε χρώμα

Βοήθεια:
1. Υπολογίστε το μέσο της Α,Β (συνάρτηση άσκησης 2), έστω Γ.
2. Υπολογίστε το slope της κάθετης στην Α,Β, (συνάρτηση άσκησης 4) , έστω λ<sup>'</sup>
3. Αν η εξίσωση της μεσοκαθέτου είναι  y = ax + b. Τότε: a = λ<sup>'</sup>. Γνωρίζουμε ένα σημείο πάνω στην μεσοκάθετο, (το Γ) οπότε μπορούμε να υπολογίσουμε το b.
4. Αφού ξέρουμε τα a,b της ευθείας της μεσοκαθέτου, ένα σημείο πάνω στη μεσοκάθετο (το Γ) και την απόσταση d, μπορούμε να χρησιμοποιήσουμε τη συνάρτηση της άσκησης 5 για να υπολογίσουμε τα Κ,Λ

Για παράδειγμα θα πρέπει:

```python
Α = (1, 2)
Β = (3, 9)
d = 4

f(A, B, d)
```

Εμφανίζει το διάγραμμα (έχω πειράξει λίγο τους άξονες για να είναι στο κέντρο το plot, σε εσάς μπορεί να είναι διαφορετικό):

![img](https://i.imgur.com/ws8OOEa.png)


### Άσκηση 83 
Η παρακάτω συνάρτηση παράγει τη διακύμανση της τιμής 2 μετοχών για 200 μέρες, όπου και οι 2 μετοχές ξεκινάνε με τη τιμή 100 και κάθε μέρα προσθέτουμε μία τυχαία τιμή από το -0.5 μέχρι το 0.5. Οι τιμές επιστρέφονται σε μία λίστα η οποία περιέχει 200 tuples ένα για κάθε μέρα. Κάθε tuple περιέχει 2 τιμές, μία για κάθε μετοχή.

```python
import random
def random_stocks()
    days = 200
    price_1 = 100
    price_2 = 100
    
    ret = [(price_1, price_2)]
    for x in range(days-1):
        price_1 += random.random() - 0.5
        price_2 += random.random() - 0.5
        ret.append((price_1, price_2))

    return ret
```

Επίσης η παρακάτω συνάρτηση (`plot_stocks`) φτιάχνει μία γραφική παράσταση με τη διακύμανση των τιμών των μετοχών. Η 1η μετοχή έχει χρώμα μπλε και η δεύτερη κόκκινο:

```python
import matplotlib.pyplot as plt
    
def plot_stocks():
    Y = random_stocks()
    X = list(range(len(Y)))

    fig, ax = plt.subplots()
    
    ax.plot(X, [y[0] for y in Y], c='blue')
    ax.plot(X, [y[1] for y in Y], c='red')
```

Για παράδειγμα:

```python
plot_stocks()
```

![img](https://i.imgur.com/L4RTKH1.png)


Μεταβάλετε τη συνάρτηση `plot_stocks` ώστε να εμφανίζεται μία κάθετη μαύρη γραμμή. Το X αυτής της γραμμής θα είναι η μέρα όπου η απόλυτη τιμή της διαφοράς των τιμών των δύο μετοχών είναι η μεγαλύτερη. Η γραμμή θα ξεκινάει από τη τιμή της μετοχής που έχει τη μικρότερη τιμή και θα σταματάει στη τιμή της μετοχής που έχει τη μεγαλύτερη τιμή. Ένα πράδειγμα δίνεται παρακάτω:


![img](https://i.imgur.com/ybBx9Ia.png)


### Άσκηση 84 
Σε [αυτό το link](https://public.tableau.com/app/profile/ryansoares/viz/WorldCup2022SquadAgeDistributions/Dashboard1) υπάρχει μία πολύ όμορφη οπτικοποίηση των ηλικιών των παικτών που πήραν μέρος στις εθνικές ομάδας στο παγκόσμιο κύπελλο ποδοσφαίρου. Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μίο λίστα με ακέραιους αριθμούς (δεν χρειάζεται να το ελέγξετε αυτό) οι οποίες θα εκπροσωπεύουν τις ηλικίες από τους 26 παίκτες. Η συνάρτηση θα πρέπει να εμφανίζει μία γραφική παράσταση με 26 τελείες όπως φαίνεται στο διάγραμμα του παραπάνω συνδέσμου. Δίνεται ένα παράδειγμα (Πολωνία):

```python 
l = [25, 27, 23, 28, 22, 25, 35, 30, 20, 27, 34, 34, 32, 24, 23, 25, 22, 31, 26, 27, 24, 25, 28, 32, 34, 20]
f(l) 
```

Εμφανίζει το παρακάτω plot:
![img](https://i.imgur.com/5296VLW.png)


### Άσκηση 85

Δίνεται η παρακάτω συνάρτηση:

```python
import pandas as pd
import re

def get_data_85():
    dfs = pd.read_html('https://en.wikipedia.org/wiki/List_of_minimum_annual_leave_by_country')
    df = dfs[0]
    
    ret = {
        x['Country']: {
            'vd': int(x['Paid vacation days by year (five-day workweek)[1][2]']), 
            'ph': int(x['Total paid leave (five-day workweek)'])
        }  for x in df.to_dict('records') 
           if not pd.isna(x['Total paid leave (five-day workweek)'])
           if re.fullmatch(r'\d+', x['Paid vacation days by year (five-day workweek)[1][2]'])
           if re.fullmatch(r'\d+', x['Total paid leave (five-day workweek)'])
    }
    
    return ret
```

Αυτή η συνάρτηση επιστρέφει ένα dictionary το οποίο περιέχει σαν κλειδιά ονόματα από χώρες και σαν τιμή ένα dictionary όπου το κλειδί `vd` περιέχει το πλήθος από μέρες με άδεια μετ' αποδοχών που μπορούν να πάρουν οι εργαζόμενοι σε αυτή τη χώρα και το κλειδί `ph` περιέχει το πλήθος από δημόσιες αργίες.

Για παράδειγμα:
```python
d = get_data_85()
print (d['Greece']) # Τυπώνει: {'vd': 20, 'ph': 32} 
``` 

Μπορούμε τώρα να φτιάξουμε μία γραφική παράσταση η οποία αντί να χρησιμοποιεί καρτεσιανές συντεταγμένες, να χρησιμοποιεί πολικές συντεταγμένες. Για παράδειγμα: Μία γραφική παράσταση η οποία δείχνει:
* Μία μπλε γραμμή στις 10 μοίρες η οποία να ξεκινάει από την ακτίνα κύκλου με μέγεθος 10 μέχρι την ακτίνα κύκλου με μέγεθος 20
* Μία κόκκινη γραμμή στις 45 μοίρες η οποία να ξεκινάει από την ακτίνα κύκλου με μέγεθος 15 μέχρι την ακτίνα κύκλου με μέγεθος 30

```python
import numpy as np

fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot([10/180 * np.pi, 10/180 * np.pi], [10, 20], c='blue')
ax.plot([45/180 * np.pi, 45/180 * np.pi], [15, 30], c='red')
```

Εμφανίζει το plot:

![img](https://i.imgur.com/B0RTqsd.png)


Αν "κρύψετε" τους άξονες η γραφική παράσταση θα γίνει:
```python
fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
ax.plot([10/180 * np.pi, 10/180 * np.pi], [10, 20], c='blue')
ax.plot([45/180 * np.pi, 45/180 * np.pi], [15, 30], c='red')
ax.axis("off")
```

![img](https://i.imgur.com/cLq1MvJ.png)

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο ένα dictionary σαν αυτό που επιστρέφει η `get_data_85()`. Η συνάρτηση:
1. Θα φτιάχνει μία λίστα με όλες τις χώρες ταξινομημένες με βάση το άθροισμα των αδειών του (`vd` + `pd`), από τη μικρότερη στη μεγαλύτερη.
2. Σε κάθε χώρα θα αντιστοιχεί μία γωνία έτσι ώστε όλες οι χώρες να καλύπτουν όλο τον κύκλο (από 0 μέχρι 360 μοίρες)
3. Για κάθε χώρα θα φτιάχνει μία κόκκινη γραμμή η οποία θα έχει γωνία τόση όση η αντίστοιχη γωνία της, θα ξεκινάει από τον κύκλο με ακτίνα 30 και θα σταματάει στον κύκλο με ακτίνα 30 συν το πλήθος από τις μέρες με άδειες με τα αποδοχών (`vd`).   
4. Για κάθε χώρα θα φτιάχνει μία μπλε γραμμή η οποία θα έχει γωνία τόση όση η αντίστοιχη γωνία της, θα ξεκινάει από τον κύκλο με ακτίνα 30 συν το πλήθος από τις μέρες με άδειες με τα αποδοχών (`vd`) και θα σταματάει στον κύκλο με ακτίνα 30 συν το συνολικό πλήθος από άδειες (`vd` + `ph`) που έχουν.

Δίνεται το plot που "βγήκε" σε εμένα:

![img](https://i.imgur.com/mUWTGKj.png)

* Σημείωση 1: Το 30 το έχω βάλει εγώ χωρίς κάποια συγκεκριμένη λογική. Εσείς μπορείτε να το προσαρμόσετε. Γενικότερα μπορείτε να προσαρμόσετε "στυλιστικά" τη γραφική παράσταση όπως θέλετε. 
* Σημείωση 2: Η άσκηση είναι εμπνευσμένη από [εδώ](https://public.tableau.com/app/profile/zsofia.nika/viz/Whichcountrygetsthemostpaidvacationdays_16711136524000/Vacation)
* Σημείωση 3: Αν θέλετε βάλτε διαφορετικά χρώματα στην Ελλάδα ώστε να ξεχωρίζει (να ξέρουμε που βρισκόμαστε σε σχέση με τους υπόλοιπους)


### Άσκηση 86 
(Εμπνευσμένη από ερώτηση της Αγάπης)

Δίνεται ο παρακάτω κώδικας:

```python
import random
import numpy as np

def bezier_curve(p0, p1, p2, p3, t):
    x = (1 - t)**3 * p0[0] + 3 * (1 - t)**2 * t * p1[0] + 3 * (1 - t) * t**2 * p2[0] + t**3 * p3[0]
    y = (1 - t)**3 * p0[1] + 3 * (1 - t)**2 * t * p1[1] + 3 * (1 - t) * t**2 * p2[1] + t**3 * p3[1]
    return (x, y)

def create_random_curve():
    p0_1 = 10*random.random()
    p0_2 = 10*random.random()
    
    p1_1 = 10*random.random()
    p1_2 = 10*random.random()
    
    p2_1 = 10*random.random()
    p2_2 = 10*random.random()

    p3_1 = 10*random.random()
    p3_2 = 10*random.random()

    p0 = (p0_1, p0_2)
    p1 = (p1_1, p1_2)
    p2 = (p2_1, p2_2)
    p3 = (p3_1, p3_2)

    d = np.array([bezier_curve(p0, p1, p2, p3, x) for x in np.linspace(0,1,100)])

    return d

```

Η συνάρτηση `create_random_curve` επιστρέφει έναν διδιάστατο πίνακα 100 Χ 2. Τα σημεία αυτά αναπαριστούν μία τυχαία καμπύλη μέσα στον στον 2-διάστατο χώρο Χ=0..10 και Υ=0..10. Μπορούμε να κάνουμε plot λοιπόν μία τυχαία καμπύλη:

```python
fig, ax = plt.subplots()
d = create_random_curve()
ax.plot(d[:, 0], d[:, 1], '-', color='black' )
```

Παράγει το παρακάτω plot (σε εσάς θα εμφανιστεί μία διαφορετική καμπύλη):

![img](https://i.imgur.com/kb59WFM.png)


Δίνεται επίσης ο παρακάτω κώδικας:
```python
from numpy.linalg import det

def left(l, b, x1, y1):

    x2 = 0
    y2 = l*x2 + b
    x3 = 10
    y3 = l*x3 + b
 
    K = np.array([[x2-x1, x3-x1], [y2-y1, y3-y1]])
    return np.sign(det(K))
```

H παραπάνω συνάρτηση (`left`) επιστρέφει:
* 1, Αν το σημείο x1, y1 είναι αριστερά της ευθείας y=lx+b
* -1, Αν το σημείο x1, y1 είναι δεξιά της ευθείας y=lx+b
* 0, Αν το σημείο x1, y1 είναι πάνω στην ευθεία  y=lx + b



Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει κανένα όρισμα. Η συνάρτηση θα:
1. Φτιάχνει και θα κάνει plot με μαύρο χρώμα μία τυχαία καμπύλη, όπως παράγεται από τη συνάρτηση `create_random_curve`.
2. Θα φτιάχνει και θα κάνει plot με μπλε χρώμα ένα τυχαίο ευθύγραμμο τμήμα που ανήκει στην ευθεία y=lx+b, όπου l ένας τυχαίος **δεκαδικός** αριθμός από -2 έως 2 και το b είναι ένας τυχαίος **δεκαδικός** αριθμός από το -2 έως το 2. Το ευθύγραμμα τμήμα θα είναι για Χ=0..10.
3. Θα βρίσκει (αν υπάρχει!) το σημείο τομής της ευθείας του βήματος 2 με τη καμπύλη του βήματος 1 (hint: συνάρτηση `left`). To σημείο τομής θα το κάνει plot ως ένα διαμάντι (`'D'`), με χρώμα κόκκινο. 

Δίνεται ένα παράδειγμα:

```python
f() # Εμφανίζει το plot
```

![img](https://i.imgur.com/b4nIIrV.png)

### Άσκηση 87 
(Εμπνευσμένη από ερώτηση του κ. Ανδρέα)

Ας φτιάξουμε τέχνη!

Από την άσκηση 86 είδαμε τη συνάρτηση `create_random_curve()` η οποία φτιάχνει τα 100 σημεία μίας τυχαίας καμπύλης στο χώρο. Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα πρέπει:

1. Φτιάχνει τα σημεία της καμπύλης καλώντας τη `create_random_curve`, και τα αποθηκεύει σε έναν πίνακα, έστω Α
2. Φτιάχνει τον πίνακα Β ο οποίoς έχει τα συμμετρικά σημεία του Α ως προς την ευθεία η οποία είναι παράλληλη του άξονα Υ και περνάει από το πιο αριστερό σημείο των σημείων του Α. Ή αλλιώς φανταστείτε ότι βάζουμε έναν καθρέπτη στο πιο αριστερό σημείο της καμπύλης των σημείων του Α.
3. Φτιάχνει τον πίνακα Γ ο οποίος έχει τα συμμετρικά σημεία του Α ως προς την ευθεία η οποία είναι παράλληλη του άγονα Χ και περνάει από το πιο "κάτω" σημείο από όλα τα σημεία του Α. Ή αλλιώς φανταστείτε ότι βάζουμε έναν καθρέπτη στο πιο κάτω σημείο της καμπύλης των σημείων του Α.
4. Φτιάχνει τον πίνακα Δ οποίος είναι για τον Γ ότι είναι ο Β για τον Α. (ότι κάνατε για για να φτιάξετε τον Β από τον Α, κάντε το στον Γ και θα έχετε τον Δ!)
5. Κάνει plot τα σημεία των πινάκων Α,Β,Γ,Δ

Δίνεται ένα παράδειγμα:
```python
f() # Εμφνανίζει το plot:
```

![img](https://i.imgur.com/lKwolsf.png)


Σημείωση: μπορείτε να επαναλάβετε τη παραπάνω διαδικασία παραπάνω από μία φορά. Δηλαδή μπορούμε να ορίσουμε έναν πίνακα Κ ο οποίος έχει όλα τα σημεία των Α,Β,Γ,Δ. Στην συνέχεια μπορούμε να ορίσουμε σαν Α τον Κ και να επαναλάβουμε τη διαδικασία με τα 5 βήματα της άσκησης 87. 

Αν το επανάλαβετε 1 φορά ακόμα θα φτιάξετε σχήματα σαν αυτό:

![img](https://i.imgur.com/8IMildN.png)

Αν το επαναλάβετε 2 φορές θα φτιάξετε σχήματα σαν αυτό:

![img](https://i.imgur.com/gaOstCy.png)

Αν το επαναλάβετε 3 φορές θα φτιάξετε σχήματα σαν αυτό:

![img](https://i.imgur.com/tFxNIj9.png)

### Άσκηση 88
Ας υποθέσουμε ότι έχουμε 2 ομάδες μπάσκετ την Α και τη Β. Έστω p η πιθανότητα η Α να νικήσει τη Β (αν p=0.5, τότε είναι ισοδύναμες). Ας υποθέσουμε ότι γίνεται ένα τουρνουά όπου συμμετέχουν μόνο αυτές οι ομάδες. Οι ομάδες παίζουν Ν αγώνες και νικητής είναι όποιος καταφέρει και πετύχει Ν//2+1 νίκες. Η πιθανότητα να νικήσει η **B** (προσοχή όχι η Α) το τουρνουά δίνεται από τη συνάρτηση:

```python
from scipy.stats import binom 

def B_wins(N, p):
    if N%2 == 0:
        return binom.cdf(N//2-1, N, p)
    
    return binom.cdf(N//2, N, p)
```   


Για παράδειγμα αν το τουρνουά αποτελείται απο 10 αγώνες και η πιθανότητα η Α να νικήσει τη Β σε κάποιο αγώνα είναι 0.6 τότε η πιθανότητα η Β να κερδίσει το τουρνουά είναι:
```python
print (B_wins(10, 0.6)) # Τυπώνει 0.16623861760000005 
```

Κάποιος διοργανωτής ανησυχεί από το γεγονός ότι η πιθανότητα αυτή είναι περίπου 1/8. Δηλαδή 1 στα 8 τουρνού που γίνονται όπου η Α είναι καλύτερη από τη Β, το κερδίζει η Β!. Θέλει αυτή η πιθανότητα να γίνει όσο το δυνατόν μικρότερη. Φτιάχνει λοιπόν τη παρακάτω συνάρτηση:

```python
def min_games(p, a):
    for N in range(3,10_000):
        if B_wins(N, p)<a:
            return N
```

Αυτή η συνάρτηση (ίσως μπορείτε να τη κάνετε καλύτερη..) επιστρέφει το πλήθος των αγώνων που πρέπει να παιχτούν σε ένα τουρνουά, ώστε η πιθανότητα να κερδίσει το τουρνουά η Β να είναι μικρότερο από a. p είναι η πιθανότητα η Α να κερδίσει τη Β σε ένα οποιοδήποτε παιχνίδι. Για παράδειγμα:

```python
print(min_games(0.6, 0.05)) # Τυπώνει: 56 
```

Αυτό σημαίνει ότι αν παιχτεί ένα τουρνουά με 56 αγώνες με 2 ομάδες Α και Β όπου η πιθανότητα σε κάθε αγώνα η Α να κερδίσει τη Β είναι 0.6 (60%), η πιθανότητα η Β να κερδίσει το τουρνουά είναι μικρότερο από 0.05. Αν παικτούν λιγότεροι από 56 αγώνες τότε η Β έχει πιθανότητα να κερδίσει το τουρνουά μεγαλύτερη από 0.05. 

Δίνεται επίσης ο παρακάτω κώδικας:
```python
fig, ax = plt.subplots()

colors =plt.cm.viridis(np.linspace(0,1,25))

for x in range(25):
    ax.plot([x, x], [0, 1], '-', c=colors[x])

```

Ο κώδικας αυτός κάνει plot 25 κάθετες γραμμές χρησιμοποιώντας χρώματα από το colormap viridis. 

![img](https://i.imgur.com/MikZmB9.png)

Φτιάξτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα πρέπει:
1. Να παίρνει όλες τις τιμές του `a` από 0.01 έως 0.1 με βήμα 0.01
2. Για κάθε `a` θα παίρνει όλες τις τιμές του `p` από 0.53 έως 0.65 με βήμα 0.005, για κάθε `a` θα υπολογίζει το αποτέλεσμα της `min_games` για τα τρέχων `p` και `a` . Μόλις τελειώσει ο υπολογισμός για όλα τα `p`, θα πλοτάρει στον Χ άξονα τις τιμές του `p` και στον Y τις τιμές της `min_games`. Σαν χρώμα θα παίρνει τιμές από το colormap viridis με βάση τη τιμη της `a`. 

Δίνεται το plot το οποίo "βγήκε" σε εμένα:

![img](https://i.imgur.com/NQcZb95.png) 


### Άσκηση 89
Η παρακάτω συνάρτηση επιστρέφει ένα pandas DataFrame με μία λίστα με μετάγραφα:

```python
import pandas as pd
def get_df_89():
    return pd.read_csv('https://www.dropbox.com/s/5e4btcptal5pp3w/ask_89.csv?dl=1')
```

Τα δεδομένα προέρχονται από τη [δημοσίευση](https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-016-2582-9): 

> Sahakyan, Aleksandr B., and Shankar Balasubramanian. "Long genes and genes with multiple splice variants are enriched in pathways linked to cancer and other multigenic diseases." BMC genomics 17, no. 1 (2016): 1-10.

To DataFrame περιέχει τις εξής στήλες:
* `TR.NAME`: όνομα του μετάγραφου κατά το RefSeq
* `GENE.NAME`: όνομα του γονιδίου
* `N.EXONS`: πλήθος από exons που έχει το μετάγραφο
* `N.INTRONS`: πλήθος από introns που έχει το μετάγραφο
* `TRANSCRIPT.L`: Μέγεθος του μετάγραφου
* `EXONS.L`: Συνολικό μέγεθος όλων των exons
* `INTRONS.L`: Συνολικό μέγεθος όλων των introns 


Γράψτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
* Καλεί τη `get_df_89` ώστε να αποθηκεύει το DataFrame σε μία μεταβλητή
* Επιστρέφει το όνομα του γονιδίου που έχει τα περισσότερα μετάγραφα. 

### Άσκηση 90
Γράψτε μία συνάρτηση η οποία δεν θα παίρνει καμία παράμετρο. Η συνάρτηση θα:
* Καλεί τη `get_df_89` ώστε να αποθηκεύει το DataFrame σε μία μεταβλητή
* Για κάθε transcript θα υπολογίζει το μέσο μήκος των exons του (δηλαδή στήλη `EXONS.L`/`N.EXONS`) και θα το αποθηκεύει σε μία νέα στήλη με το όνομα `AV.EXON.L`
* Για κάθε transcript θα υπολογίζει το μέσο μήκος των introns του (δηλαδή στήλη `INTRONS.L`/`N.INTRONS`) και θα το αποθηκεύει σε μία νέα στήλη με το όνομα `AV.INTRONS.L`
* Για κάθε transcript θα υπολογίζει το `AV.EXON.L` / `AV.INTRONS.L` και θα τα αποθηκεύει σε μία νέα στήλη με το όνομα: `AV.EXON.DIV.INTRON`
* Για κάθε γονίδιο θα υπολογίζει τον μέσο όρο του `AV.EXON.DIV.INTRON` για όλα τα transcripts του.
* Θα αφαιρεί τα γονίδια για τα οποία αυτός ο μέσος είναι είναι `NaN`.
* Θα ταξινομεί τα γονίδια από αυτα που έχουν μικρότερο μέσο όρο με αυτά που έχουν μεγαλύτερο μέσο όρο
* Θα κάνει `line` plot (`kind=line`) όπου ο άξονας Υ θα έχει λογαριθμική κλίμακα (`logy=True`).

Το plot που βγήκε σε μένα είναι:

![img](https://i.imgur.com/eWJPzSS.png)

Εσείς μπορείτε να το βελτιώσετε αισθητικά!

### Άσηση 91 
Δίνεται ο generator `prime_generator` ο οποίος κάνει generate όλους τους πρώτους αριθμούς:

```python
import math
def is_prime(n):
    for x in range(2, int(math.sqrt(n))+1):
        if n% x == 0:
            return False
    return True


def prime_generator():
    yield 2
    current = 3
    while True:
        if is_prime(current):
            yield current
        current += 2
```

Για παράδειγμα o παρακάτω κώδικας τυπώνει τους πρώτους 100 πρώτους:
```python
c = 0
for x in prime_generator():
    print (x)
    c += 1
    if c>=100:
        break
```

Φτιάξτε έναν generator ο οποίος θα παίρνει σαν παράμετρο έναν ακέραιο αριθμό n. Ο generator θα κάνει generate tuples τα οποία θα περιέχουν ζευγάρια από ακέραιους αριθμούς α,β, τέτοια ώστε:
* β-α = n
* να μην υπάρχει κανένας πρώτος αριθμός από το α μέχρι και το β

Δίνονται μερικά παραδείγματα (θεωρούμε ότι η υλοποίση βρίσκεται στον generator με όνομα `gen_91`):
```python
# Κάνει generate διαστήματα μεγέθους 3
for i,pair in enumerate(gen_91(3)):
    print (pair)
    if i>10:
        break

# Τυπώνει 
(24, 27)
(25, 28)
(32, 35)
(33, 36)
(48, 51)
(49, 52)
(54, 57)
(55, 58)
(62, 65)
(63, 66)
(74, 77)
```

```python
# Κάνει generate διαστήματα μεγέθους 4
for i,pair in enumerate(gen_91(4)):
    print (pair)
    if i>10:
        break

# Τυπώνει 
(24, 28)
(32, 36)
(48, 52)
(54, 58)
(62, 66)
(74, 78)
(84, 88)
(90, 94)
(91, 95)
(92, 96)
(114, 118)
```

```python
# Κάνει generate διαστήματα μεγέθους 10
for i,pair in enumerate(gen_91(10)):
    print (pair)
    if i>10:
        break

# Τυπώνει 
(114, 124)
(115, 125)
(116, 126)
(200, 210)
(212, 222)
(294, 304)
(295, 305)
(296, 306)
(318, 328)
(319, 329)
(320, 330)
```


Σημείωση: είναι υποχρεωτικό να χρησιμοποιήσετε τον generator `prime_generator`. Δεν επιτρέπεται να χρησιμοποιήσετε κάποια άλλη γεννήτρια πρώτων αριθμών. 


### Άσκηση 92
Σε αυτό το link: https://www.dropbox.com/s/3my2injwaw0sj29/words_greek_normalized.txt?dl=0 υπάρχει ένα αρχείο με το όνομα `words_greek_normalized.txt` το οποίο περιέχει όλες τις ελληνικές λέξεις. Οι λέξεις είναι κανονικοποιημένες δηλαδή:
* Όλα είναι μικρά
* Οι τόνοι και τα διαλυτικά έχουν αντικατασταθεί με τα αντίστοιχα γράμματά τους (π.χ ά --> α)
* Το τελικό `ς` έχει αντικατασταθεί με το `σ`.

Ας παίξουμε [λέξλη](https://lexli.gr/)!!

Για αρχή διαβάστε πως παίζεται το παιχνίδι (υπάρχει στη σελίδα του παιχνιδιού). 

Στη συνέχεια δίνεται ο παρακάτω generator:
```python
def greek_word_gen():
    fn = 'words_greek_normalized.txt' # Αλλάξτε το αυτό με το path που βρίσκεται το αρχείο στον υπολογιστή σας
    with open(fn) as f:
        for l in f:
            yield l.strip()
```

Ή το ισοδύναμό του:
```python
greek_word_gen = (l.strip() for l in open(fn))
```

O generator `greek_word_gen` κάνει generate ελληνικές λέξεις. Για παράδειγμα:
```python
g = greek_word_gen()
print (next(g)) # ααχεν
print (next(g)) # αβα
print (next(g)) # αβαι
```

Φτιάξτε έναν generator ο οποίος θα παίρνει 3 παραμέτρους:
* Η παράμετρος `gen` θα είναι ένας generator o οποίος θα κάνει generate ελληνικές λέξεις.
* H παράμετρος `tried` θα είναι ένα string με μία ελληνική λέξη (με μικρά, χωρίς τόνους) η οποία θα είναι μία λέξη που βάλατε στο λέξλι.
* Η παράμετρος `pattern` θα είναι το αποτέλεσμα που έδειξε το "λέξλη" όταν δοκιμάσατε το `tried` στο παιχνίδι. Το `pattern` θα είναι ένα string με 5 χαρακτήρες οι οποίοι θα είναι είτε: `'0'` είτε `'1'` είτε `'2'`:
    * Το `'0'` σημαίνει ότι δεν υπάρχει αυτός ο χαρακτήρας σε καμία θέση (δηλαδή είχε χρώμα γκρι)
    * Το `'1'` σημαίνει ότι υπάρχει ο χαρακτήρας αλλά σε άλλη θέση (δηλαδή είχε χρώμα κίτρινο).
    * Το `'2'` σημαίνει ότι ο χαρακτήρας είναι σωστός (δηλαδή είχε χρώμα πράσινο). 

Για παράδειγμα ας υποθέσουμε ότι `pattern='χωροσ'` και το "λέξλη" επέστρεψε: `00210`. Αυτό σημαίνει ότι:
  * Τα `'Χ'`, `'Ω'`, `'Σ'` δεν υπάρχουν πουθενά στη λέξη που ψάχνουμε
  * Το `'Ο'` υπάρχει αλλά όχι στη 4η θέση. 
  * Το `'Ρ'` υπάρχει και είναι στη 3η θέση.   

Ο generator σας θα πρέπει να κάνει generate λέξεις οι οποίες: 
  * Παράγονται από τον generator της παραμέτρου `gen`
  * Ικανοποιούν τους περιορισμούς των παραμέτρων `tried` και `pattern`

Για παράδειγμα ας υποθέσουμε το κουίζ της 17 Ιανουαρίου 2023 και ότι ξεκινάμε με τη λέξη 'τρελα' :

![img](https://i.imgur.com/TB5xlbq.png)


Αν ο ζητούμενος generator είναι ο `gen_92` τότε θα πρέπει:


```python
g1 = greek_word_gen()
g2 = gen_92(g1, 'τρελα', '01000')
g3 = gen_92(g2, 'χωροσ', '00210') # To "χωροσ" είναι ένα από αυτά που έκανε yield ο g2, το επέλεξα τυχαία
g4 = gen_92(g3, 'μορφη', '12200') # To "μορφη" είναι ένα από αυτά που έκανε yield ο g3, το επέλεξα τυχαία
for x in g4:
    print (x)

# Τυπώνει:
κορμι
κορμο
```


### Άσκηση 93 
Ένας περίεργος καθηγητής προγραμματισμού, απαιτεί οι φοιτητές να παραδώσουν 100 ασκήσεις. Κάθε άσκηση θα πρέπει να ξεκινάει με ένα σχόλιο το οποίο να έχει την εξής μορφή:

```text
# exercise XYZ
...
``` 

Όπου `ΧΥΖ` ένας αριθμός από το 1 μέχρι και το 100. 

Για να διορθώσει τις ασκήσεις, έχει υλοποιήσει έναν generator ο οποίος παίρνει σαν παράμετρο ένα αρχείο το οποίο έχει τις ασκήσεις ενός φοιτητή. Ο generator κάνει generate ένα tuple το οποίο περιέχει 2 στοιχεία. Το πρώτο είναι ο αριθμός της άσκησης και το 2ο είναι η υλοποίησή της. Τα tuples γίνονται generate ταξινομημένα ανάλογα με τον αριθμό της άσκησης. Δίνεται ένα παράδειγμα:


Έστω ένα αρχείο  με το όνομα `mitsos_exercises.txt` το οποίο περιέχει:

```text
My name is Mitsos. Here are my fabulous exercises:

# exercise 3
def f():
   print ('hello world')

# exercise 1 
def f():
   print (1+2)

# exercise 2
def f():
   print ('1' + '2')
```

Τότε θα πρέπει:

```python
g = gen_93('mitsos_exercises.txt')
a,b = next(g)
print (a) # Τυπώνει 1
print (b) # Τυπώνει 
'''
def f():
   print (1+2)
'''

a,b = next(g)
print (a) # Τυπώνει 2
print (b) # Τυπώνει 
'''
def f():
   print ('1' + '2')
'''
```

### Άσκηση 94

Έστω ο παρακάτω generator:
```python
def line_generator(fn):
    with open(fn) as f:
        for l in f:
            yield l.strip()
```

Φτιάξτε έναν generator ο οποίος θα παίρνει σαν παράμετρο ένα [FASTQ](https://en.wikipedia.org/wiki/FASTQ_format) αρχείο. Ο generator θα πρέπει να κάνει generate tuples τα οποία να περιέχουν 2 στοιχεία. Το πρώτο θα είναι ένα string με τον κωδικό της αλληλουχίας και το 2ο θα είναι όλη η αλληλουχία. Μπορείτε να πάρετε ένα FASTQ file από [εδώ](https://zenodo.org/record/3736457) για να δοκιμάσετε την υλοποίησή σας. Προσοχή υπάρχουν κάποιοι περιορισμοί:

* Απαγορεύεται να κάνετε 'read' όλο το αρχείο στη μνήμη (π.χ. f.read() ή f.readlines())
* Πρέπει να χρησιμοποιήσετε μονο generator comprehensions και τον generator `line_generator`.

Για παράδειγμα έστω ότι αρχείο `example.fastq` περιέχει τα εξής δεδομένα (είναι το [παράδειγμα από τη wikipedia](https://en.wikipedia.org/wiki/FASTQ_format)). 
```
@SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36
GGGTGATGGCCGCTGCCGATGGCGTCAAATCCCACC
+SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36
IIIIIIIIIIIIIIIIIIIIIIIIIIIIII9IG9IC
@SRR001666.2 071112_SLXA-EAS1_s_7:5:1:801:338 length=36
GTTCAGGGATACGACGTTTGTATTTTAAGAATCTGA
+SRR001666.2 071112_SLXA-EAS1_s_7:5:1:801:338 length=36
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII6IBI
```

Τότε θα πρέπει:
```python
g = gen_94('example.fasta')

a,b = next(g)
print(a) # Τυπώνει: 'SRR001666.1 071112_SLXA-EAS1_s_7:5:1:817:345 length=36'
print(b) # Τυπώνει: 'GGGTGATGGCCGCTGCCGATGGCGTCAAATCCCACC'

a,b = next(g)
print (a) # Τυπώνει:'SRR001666.2 071112_SLXA-EAS1_s_7:5:1:801:338 length=36'
print (b) # Τυπώνει: 'GTTCAGGGATACGACGTTTGTATTTTAAGAATCTGA'
```

Hint: [itertools.groupby](https://docs.python.org/3/library/itertools.html#itertools.groupby) 

### Άσκηση 95 
Φτιάξτε μία κλάση με το όνομα Line η οποία να αναπαριστάει μία γραμμή. Θα πρέπει να μπορώ να γράφω:

```python
l = Line(3,5)
print (l) # Τυπώνει: y = 3*x + 5
```

### Άσκηση 96
Στη κλάση Line της άσκησης 95 προσθέστε τη μέθοδο: `is_parallel` η οποία θα παίρνει σαν παράμετο ένα αντικείμενο της κλάσης Line και θα επιστρέφει `True` αν η self είναι παράλληλη με τη παράμετρο αυτή. Για παράδειγμα θα πρέπει:

```python
l_1 = Line(3,5)
l_2 = Line(3,7)
l_3 = Line(4,5)

print (l_1.is_parallel(l_2)) # Τυπώνει True
print (l_1.is_parallel(l_3)) # Τυπώνει False

```

### Άσκηση 97
Κάντε το ίδιο με την άσκηση 96 αλλά χρησιμοποιήστε τον τελεστή `|`. Δηλαδή θα πρέπει:

```python
l_1 = Line(3,5)
l_2 = Line(3,7)
l_3 = Line(4,5)

print (l_1 | l_2) # Τυπώνει Τrue
print (l_1 | l_3) # Τυπώνει False
```

Σημείωση: Ο τελεστής `|` υλοποιείται στη συνάρτηση `__or__`

### Άσκηση 98
Υλοποιήστε τη κλάση `LineCollection` η οποία διαχερίζεται μία συλλογή από γραμμές. Η κλάση αυτή θα μπορεί να αρχικοποιηθεί με μία λίστα από αντικείμενα τύπου Line (όπως αυτό της άσκησης 96). Η κλάση αυτη θα μπορεί να γίνει iterate (υλοποιήστε της μεθόδους `__iter__ ` και `__next__`). Σε κάθε iteration θα επιστρέφει ένα ζευγάρι από της γραμμές που περιέχει οι οποίες θα είναι παράλληλες. Αυτό το iteration θα τερματίζει όταν θα έχει κάνει generate όλα τα ζευγάρια από παράλληλες γραμμές (Hint: Άσκηση 44). Για παράδειγμα θα πρέπει να μπορώ να γράφω:

```python
l = [
 (1, 96),
 (2, 92),
 (1, 11),
 (1, 25),
 (1, 90),
 (3, 41),
 (3, 75),
 (2, 37),
 (1, 43),
 (3, 68),
 (1, 32),
 (2, 4),
 (3, 25),
 (2, 2),
 (2, 70),
 (1, 98),
 (3, 51),
 (3, 65),
 (2, 52),
 (2, 85),
]

lines = [Line(x[0], x[1]) for x in l]
lc = LineCollection(lines)


for a,b in lc:
    print (f'{a} is parallel to {b}')

```  

Αυτό τυπώνει

```
y=1*x + 96 is parallel to y=1*x + 11
y=1*x + 96 is parallel to y=1*x + 25
y=1*x + 96 is parallel to y=1*x + 90
y=1*x + 96 is parallel to y=1*x + 43
y=1*x + 96 is parallel to y=1*x + 32
y=1*x + 96 is parallel to y=1*x + 98
y=2*x + 92 is parallel to y=2*x + 37
y=2*x + 92 is parallel to y=2*x + 4
y=2*x + 92 is parallel to y=2*x + 2
y=2*x + 92 is parallel to y=2*x + 70
y=2*x + 92 is parallel to y=2*x + 52
y=2*x + 92 is parallel to y=2*x + 85
y=1*x + 11 is parallel to y=1*x + 25
y=1*x + 11 is parallel to y=1*x + 90
y=1*x + 11 is parallel to y=1*x + 43
y=1*x + 11 is parallel to y=1*x + 32
y=1*x + 11 is parallel to y=1*x + 98
y=1*x + 25 is parallel to y=1*x + 90
y=1*x + 25 is parallel to y=1*x + 43
y=1*x + 25 is parallel to y=1*x + 32
y=1*x + 25 is parallel to y=1*x + 98
y=1*x + 90 is parallel to y=1*x + 43
y=1*x + 90 is parallel to y=1*x + 32
y=1*x + 90 is parallel to y=1*x + 98
y=3*x + 41 is parallel to y=3*x + 75
y=3*x + 41 is parallel to y=3*x + 68
y=3*x + 41 is parallel to y=3*x + 25
y=3*x + 41 is parallel to y=3*x + 51
y=3*x + 41 is parallel to y=3*x + 65
y=3*x + 75 is parallel to y=3*x + 68
y=3*x + 75 is parallel to y=3*x + 25
y=3*x + 75 is parallel to y=3*x + 51
y=3*x + 75 is parallel to y=3*x + 65
y=2*x + 37 is parallel to y=2*x + 4
y=2*x + 37 is parallel to y=2*x + 2
y=2*x + 37 is parallel to y=2*x + 70
y=2*x + 37 is parallel to y=2*x + 52
y=2*x + 37 is parallel to y=2*x + 85
y=1*x + 43 is parallel to y=1*x + 32
y=1*x + 43 is parallel to y=1*x + 98
y=3*x + 68 is parallel to y=3*x + 25
y=3*x + 68 is parallel to y=3*x + 51
y=3*x + 68 is parallel to y=3*x + 65
y=1*x + 32 is parallel to y=1*x + 98
y=2*x + 4 is parallel to y=2*x + 2
y=2*x + 4 is parallel to y=2*x + 70
y=2*x + 4 is parallel to y=2*x + 52
y=2*x + 4 is parallel to y=2*x + 85
y=3*x + 25 is parallel to y=3*x + 51
y=3*x + 25 is parallel to y=3*x + 65
y=2*x + 2 is parallel to y=2*x + 70
y=2*x + 2 is parallel to y=2*x + 52
y=2*x + 2 is parallel to y=2*x + 85
y=2*x + 70 is parallel to y=2*x + 52
y=2*x + 70 is parallel to y=2*x + 85
y=3*x + 51 is parallel to y=3*x + 65
y=2*x + 52 is parallel to y=2*x + 85
```

### Άσκηση 99
Υλοποιήστε την άσκηση 4 με τις παρακάτω διαφορές:

* Αν τα Α και Β δεν είναι και τα 2 tuples με 2 αριθμούς το κάθε ένα (`int` ή `float`)  τότε θα πετάει το exception [TypeError](https://docs.python.org/3/library/exceptions.html#TypeError) με το μήνυμα: "λάθος τύπος"

* Αν τα 2 σημεία Α,Β ταυτίζονται στον 2-διάστατο χώρο, τότε η συνάρτηση θα πρέπει να πετάει το exception [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError) με το μήνυμα: `δεν υπάρχει ευθεία`
* Αν τα Α και Β ανήκουν σε μία ευθεία παράλληλη στον άξονα Χ, τότε η συνάρτηση θα πρέπει να πετάει το exception [ValueError](https://docs.python.org/3/library/exceptions.html#ValueError) με το μήμυμα: `οριζόντια ευθεία`. 


### Άσκηση 100
Έστω `f_99` η υλοποίηση της άσκησης 99. Δίνεται ο παρακάτω κώδικας:

```python

def f_100(a,b):

    try:
        f_99(a,b)
    # ΔΙΚΟ ΣΑΣ!

def test_f_100():

    f_100( 5, 7.8) 
    f_100( ('mitsos', 2), (3, 'maria'), )
    f_100( (2,3), (2,3) )
    f_100( (2,3), (5,3) )
    f_100( (3,7), (2,5) )


```

Συμπληρώστε τον κώδικα της συνάρτησης `f_100`  από εκεί που λέει `ΔΙΚΟ ΣΑΣ!` και κάτω, έτσι ώστε ο παράκατω κώδικας:

```python
test_f_100()
```

Να τυπώνει:
```
TypeError: Λάθος τύπος
TypeError: Λάθος τύπος
ValueError: Δεν υπάρχει ευθεία
ValueError: οριζόντια ευθεία
Η απάντηση είναι: -0.5
```

